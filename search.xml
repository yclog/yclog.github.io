<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Gradle配置收纳</title>
      <link href="/2018/12/06/Gradle%E9%85%8D%E7%BD%AE%E6%94%B6%E7%BA%B3/"/>
      <url>/2018/12/06/Gradle%E9%85%8D%E7%BD%AE%E6%94%B6%E7%BA%B3/</url>
      <content type="html"><![CDATA[<h3 id="单元测试配置："><a href="#单元测试配置：" class="headerlink" title="单元测试配置："></a>单元测试配置：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Junit</span></span><br><span class="line">testImplementation <span class="string">"junit:junit:4.12"</span></span><br><span class="line"><span class="comment">// Mockito</span></span><br><span class="line">testImplementation <span class="string">"org.mockito:mockito-core:2.22.0"</span></span><br><span class="line">testImplementation <span class="string">"com.nhaarman.mockitokotlin2:mockito-kotlin:2.0.0-RC2"</span></span><br><span class="line"><span class="comment">// Dagger2</span></span><br><span class="line">implementation <span class="string">"com.google.dagger:dagger:2.11"</span></span><br><span class="line">implementation <span class="string">"com.google.dagger:dagger-android:2.11"</span></span><br><span class="line">implementation <span class="string">"com.google.dagger:dagger-android-support:2.11"</span></span><br><span class="line">annotationProcessor <span class="string">"com.google.dagger:dagger-android-processor:2.11"</span></span><br><span class="line">annotationProcessor <span class="string">"om.google.dagger:dagger-compiler:2.11"</span></span><br><span class="line"><span class="comment">// Robolectric</span></span><br><span class="line">testImplementation <span class="string">"org.robolectric:robolectric:3.8"</span></span><br><span class="line">android &#123;</span><br><span class="line">   <span class="comment">//Other Config</span></span><br><span class="line"></span><br><span class="line">   testOptions &#123;</span><br><span class="line">       unitTests &#123;</span><br><span class="line">           includeAndroidResources = <span class="keyword">true</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元测试Kotlin配置all-open注解配置："><a href="#单元测试Kotlin配置all-open注解配置：" class="headerlink" title="单元测试Kotlin配置all-open注解配置："></a>单元测试Kotlin配置all-open注解配置：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.创建单独的notation类文件：annotation <span class="class"><span class="keyword">class</span> <span class="title">Mockable</span></span></span><br><span class="line">2.在build.gradle(对应Project)添加：classpath "org.jetbrains.kotlin:kotlin-allopen:$kotlin_version"</span><br><span class="line"><span class="number">3</span>.在build.gradle(Module:app)中添加：</span><br><span class="line">apply plugin: <span class="string">'kotlin-allopen'</span></span><br><span class="line">allOpen &#123;</span><br><span class="line">    annotation(<span class="string">'test.com.ktmvvm.JunitTest.Mockable'</span>)  <span class="comment">//value值为notation文件</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">4</span>.向对应的Mockito.mock(Sample::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)中<span class="title">Sample</span>.<span class="title">kt</span>文件对<span class="title">class</span>文件添加注解，<span class="title">For</span> <span class="title">Example</span>：</span></span><br><span class="line"><span class="class">@<span class="title">Mockable</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Calculator</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###已有项目添加单元测试依赖以及文件夹</p><ul><li>Junit</li></ul><ol><li>对gradle文件添加依赖</li><li>src文件下创建test文件夹(与main同级)，为方便后期管理，在test文件下创建与main文件夹下对应路径以及文件夹</li></ol><ul><li>AndroidJunit</li></ul><ol><li>不需要添加单独依赖</li><li>src文件下创建androidTest(与main同级)，其余相同</li></ol><h3 id="Kotlin配置："><a href="#Kotlin配置：" class="headerlink" title="Kotlin配置："></a>Kotlin配置：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">'kotlin-android'</span></span><br><span class="line">apply plugin: <span class="string">'kotlin-android-extensions'</span></span><br><span class="line">kapt &#123;</span><br><span class="line">    generateStubs = <span class="keyword">true</span></span><br><span class="line">&#125;</span><br><span class="line">implementation<span class="string">"org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version"</span></span><br><span class="line"></span><br><span class="line">build.gradle(对应Project)添加：</span><br><span class="line">classpath <span class="string">"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"</span></span><br><span class="line">classpath <span class="string">"org.jetbrains.kotlin:kotlin-allopen:$kotlin_version"</span></span><br></pre></td></tr></table></figure><h3 id="DataBinding配置："><a href="#DataBinding配置：" class="headerlink" title="DataBinding配置："></a>DataBinding配置：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">'kotlin-kapt'</span></span><br><span class="line">android&#123;</span><br><span class="line">    ...</span><br><span class="line">    dataBinding &#123;</span><br><span class="line">        enabled = <span class="keyword">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">kapt &#123;</span><br><span class="line">    generateStubs = <span class="keyword">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此处版本号与当前项目gradle版本号对齐</span></span><br><span class="line">kapt <span class="string">"com.android.databinding:compiler:3.1.4"</span></span><br></pre></td></tr></table></figure><h3 id="LeakCanary"><a href="#LeakCanary" class="headerlink" title="LeakCanary"></a>LeakCanary</h3><p>BaseApplication onCreate方法设置<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>.onCreate();</span><br><span class="line"><span class="keyword">if</span> (LeakCanary.isInAnalyzerProcess(<span class="keyword">this</span>)) &#123;</span><br><span class="line">    <span class="comment">// This process is dedicated to LeakCanary for heap analysis.</span></span><br><span class="line">    <span class="comment">// You should not init your app in this process.</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">LeakCanary.install(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">debugImplementation <span class="string">'com.squareup.leakcanary:leakcanary-android:1.6.2'</span></span><br><span class="line">releaseImplementation <span class="string">'com.squareup.leakcanary:leakcanary-android-no-op:1.6.2'</span></span><br><span class="line"><span class="comment">// Optional, if you use support library fragments:</span></span><br><span class="line">debugImplementation <span class="string">'com.squareup.leakcanary:leakcanary-support-fragment:1.6.2'</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android之多线程解析(二)之Runnable、Callable、FutureTask </title>
      <link href="/2018/08/01/Android%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%A7%A3%E6%9E%90-%E4%BA%8C-%E4%B9%8BRunnable%E3%80%81Callable%E3%80%81FutureTask/"/>
      <url>/2018/08/01/Android%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%A7%A3%E6%9E%90-%E4%BA%8C-%E4%B9%8BRunnable%E3%80%81Callable%E3%80%81FutureTask/</url>
      <content type="html"><![CDATA[<h4 id="与多线程相关的方法—Callable-Future以及FutureTask"><a href="#与多线程相关的方法—Callable-Future以及FutureTask" class="headerlink" title="与多线程相关的方法—Callable,Future以及FutureTask"></a>与多线程相关的方法—Callable,Future以及FutureTask</h4><p>除了上文中一直分析的Runnable之外，Java中还存在Callbale，Future，FutureTask与多线程相关的概念，与Runnable不同的则是这三个方法只能用于线程池中，Runnable则可以同时在运用在Thread和线程池中。<br></p><p>Callable与Runnable功能相似，不同在与Callable是一个泛型接口，他有一个泛型参数V，该接口中有一个返回值(类型为V)的call()函数，而Runnable的run函数不能将结果返回到客户程序中：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line"><span class="comment">//返回V类型的结果</span></span><br><span class="line"><span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//为加深理解，假如Runnable的源码作为对比</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="comment">//返回V类型的结果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>博客看到此处，即对Runnable以及Callable有了比较大致的了解，但是这两种机制存在着一个无法避免的缺陷，即一旦使用后就很难做到有效的控制。而Future的出现即解决了这种问题，Future为线程池制订了可管理的任务标准。Future提供了对Runnable或者Callable的任务的执行结果进行管理(取消，查询是否完成，获取结果，设置结果;分别对应着cancel,isDone,get,set函数，且get函数调用后会发生阻塞，直到执行完成返回结果)。Future声明如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException,ExecutionException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout,TimeUint unit)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> InterruptedException,ExecutionException,TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Future只是定义了一些规范的接口，FutureTask则是具体的实现类。FutureTask实现了RunnableFuture<v>，而RunnableFuture实现了Runnable又实现了Future<v>这两个接口，因此FutureTask同时具有两者的能力。FutureTask代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line"><span class="comment">//代码省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></v></v></p><p>再看RunnabelFuture类定义:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnabelFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Runnable</span>,<span class="title">Future</span>&lt;<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>FutureTask会像Thread包装Runnable那样对Runnable和Callbale<v>进行包装，Runnbale与Callbale由构造函数注入。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(callable==<span class="keyword">null</span>) <span class="function"><span class="keyword">throws</span> new <span class="title">NullPointerException</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">this</span>.callable=callable;</span><br><span class="line"><span class="keyword">this</span>.state=NEW;<span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable,V result)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.callable=Executors.callable(runnable,result);</span><br><span class="line"><span class="keyword">this</span>.state=NEW;<span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></v></p><p>由上述代码即可看出，无论在构造函数中传输runnable或callable对象，都会被转换为callable对象，即可知道最终都是对Callable对象进行操作，该适配函数的实现如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task,T result)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(task==<span class="keyword">null</span>) <span class="function"><span class="keyword">throws</span> new <span class="title">NullPointerException</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;T&gt;(task,result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableAdapter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"><span class="keyword">final</span> Runnable task;</span><br><span class="line"><span class="keyword">final</span> T result;</span><br><span class="line">RunnableAdapter(Runnable task,T result)&#123;</span><br><span class="line"><span class="keyword">this</span>.task=task;</span><br><span class="line"><span class="keyword">this</span>.result=result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">task.run();</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于FutureTask实现了Runnable，因此它既可以通过Thread包装来直接执行，也可提交给ExecuteService来执行。且可直接通过get()获取执行结果，该函数会一直阻塞到结果返回。因此，FutureTask既是Future，Runnable，又包装了Callable，即为两者的合体<br><br>下面通过一个Java程序简单演示Runnable，Callable，FutureTask的运用:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> ExecutorService mExecutor=Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">FutureWithRunnable();</span><br><span class="line">FutureWithCallable();</span><br><span class="line">FutureWithFutureTask();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">FutureWithRunnable</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException,ExecutionException</span>&#123;</span><br><span class="line">Future&lt;?&gt; result=mExecutor.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">fibc(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">"Future result from Runnable : "</span>+result.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">FutureWithCallable</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException,ExecutionException</span>&#123;</span><br><span class="line">Future&lt;Integer&gt; result2=mExecutor.submit(<span class="keyword">new</span> Callable&lt;Integer&gt;()&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> fibc(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">"Future result from Callable : "</span>+result2.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">FutureWithFutureTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException,ExecutionException</span>&#123;</span><br><span class="line">FutureTask&lt;Integer&gt; futuretask=<span class="keyword">new</span> FutureTask&lt;Integer&gt;(</span><br><span class="line"><span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">return</span> fibc(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">mExecutor.submit(futuretask);</span><br><span class="line">System.out.println(<span class="string">"Future result from FutureTask : "</span>+futuretask.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibc</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(num == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(num == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> fibc(num-<span class="number">1</span>)+fibc(num-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果为：<br>Future result from Runnable : null<br>Future result from Callable : 6765<br>Future result from FutureTask : 6765</p><p>由上述示例代码以及结果可以看出，以Runnable作为对象的执行后的结果无法通过get()函数方法获得。而使用Callable以及调用Callable的FutureTask可以通过get()函数获取执行后的结果。</p>]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android之多线程解析(一)之Thread、Runnable</title>
      <link href="/2018/08/01/Android%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%A7%A3%E6%9E%90-%E4%B8%80-%E4%B9%8BThread%E3%80%81Runnable/"/>
      <url>/2018/08/01/Android%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%A7%A3%E6%9E%90-%E4%B8%80-%E4%B9%8BThread%E3%80%81Runnable/</url>
      <content type="html"><![CDATA[<h4 id="多线程实现之Thread和Runnable"><a href="#多线程实现之Thread和Runnable" class="headerlink" title="多线程实现之Thread和Runnable"></a>多线程实现之Thread和Runnable</h4><p>Android的多线程实现最基础部分应该该为Thread和Runnable，通常情况下使用两种方式的启动方式如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startNewThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>启动带Runnable参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startNewThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">//耗时操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对示例一，实例二代码进行分析：实例一中代码使用Thread内的run函数执行操作，实例二中代码实际上为Thread的构造函数传递了一个Runnable对象，使用Runnable对象内的run方法执行耗时操作。两者之间的区别分析如下：<br></p><p><em>Thread源码如下：</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="comment">//线程所属的ThreadGroup</span></span><br><span class="line">  <span class="keyword">private</span> ThreadGroup group;</span><br><span class="line">  <span class="comment">//需要执行的Runnable对象</span></span><br><span class="line">  <span class="keyword">private</span> Runnable target;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      init(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span> </span>&#123;</span><br><span class="line">      init(<span class="keyword">null</span>, target, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name, <span class="keyword">long</span> stackSize)</span> </span>&#123;</span><br><span class="line">      Thread parent = currentThread();</span><br><span class="line">      <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">          g = parent.getThreadGroup();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      g.addUnstarted();</span><br><span class="line">      <span class="keyword">this</span>.group = g;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.target = target;</span><br><span class="line">      <span class="keyword">this</span>.priority = parent.getPriority();</span><br><span class="line">      <span class="keyword">this</span>.daemon = parent.isDaemon();</span><br><span class="line">      setName(name);</span><br><span class="line">      <span class="comment">//代码省略</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//为了节约长度，只提取了核心代码进行处理</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">    group.add(<span class="keyword">this</span>);</span><br><span class="line">    nativeCreate(<span class="keyword">this</span>, stackSize, daemon);</span><br><span class="line">    started = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">         target.run();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从官方源代码中对init函数功能描述为<em>初始化线程</em>，第一个参数ThreadGroup为线程组，第二个参数target为当前线程的Runnable对象。源码init函数功能注释为：<br></p><p><em>group threads created/set up by the VM. Any new functionality added to this method in the future may have to also be added to the VM.</em><br>中文对应翻译过来即为：<strong>线程组在Android的虚拟机中创建或者设置，任何新功能都能被添加到该方法中在以后将会被添加到Android的虚拟机中</strong>。<br></p><p>对上述代码中start函数进行分析，根据group.add(this)函数即为将当前线程添加到线程组中，依据Android虚拟机自行调度运行中。对源代码的run方法进行分析，当启动一个线程时，如果Thread的target不为空，则会在子线程汇总执行这个target的run方法。否则虚拟机将会执行线程自身的run函数。<br></p><h3 id="线程的wait，sleep，join和yield方法"><a href="#线程的wait，sleep，join和yield方法" class="headerlink" title="线程的wait，sleep，join和yield方法"></a>线程的wait，sleep，join和yield方法</h3><table><thead><tr><th>函数名</th><th>含义</th></tr></thead><tbody><tr><td>wait</td><td>线程执行后，进入到与对象相关的等待池中，同时释放了对象的机锁。使其他线            程可以访问，用户可以使用notify、notifyAll或者指定睡眠时间后唤醒</td></tr><tr><td>sleep</td><td>该函数为Thread的静态函数，使调用线程进入睡眠状态，由于是static方法， 所以无法改变对象的机锁。所以，当在一个synchronized块中调用sleep方法。虽然休眠了，但是对象的机制并没有释放，其他线程无法访问该对象</td></tr><tr><td>join</td><td>等待目标线程执行完成之后再继续执行</td></tr><tr><td>yield</td><td>线程礼让，目标线程由运行状态换为就绪状态，即让出执行权限，其他线程优先执行。其他线程是否能够优先执行不可知。</td></tr></tbody></table><p><br><br><em>Notes:为提高程序的可理解性，此处以及下面引入synchronized机制</em></p><h5 id="以下为对wait，notify与notifyAll的应用"><a href="#以下为对wait，notify与notifyAll的应用" class="headerlink" title="以下为对wait，notify与notifyAll的应用"></a>以下为对wait，notify与notifyAll的应用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"主线程运行"</span>);</span><br><span class="line">Thread thread=<span class="keyword">new</span> WaitThread();</span><br><span class="line">thread.start();</span><br><span class="line"><span class="keyword">long</span> starttime=System.currentTimeMillis();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (sLockObject) &#123;</span><br><span class="line">System.out.println(<span class="string">"主线程等待"</span>);</span><br><span class="line">sLockObject.wait();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> timeMs=(System.currentTimeMillis()-starttime);</span><br><span class="line">System.out.println(<span class="string">"主线程继续--&gt;等待耗时："</span>+timeMs+<span class="string">" ms"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (sLockObject) &#123;</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">sLockObject.notifyAll();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前运行结果为:</p><blockquote></blockquote><p>主线程运行<br>主线程等待<br>主线程继续–&gt;等待耗时：3001 ms</p><p>上述代码为，首先在主线程中synchronized块中调用wait方法，使WaitThread进入等待池，此时主线程停止运行，由于WaitThread中的synchronized块为设置睡眠时间为3秒，三秒后调用notifyAll()方法，使WaitThread线程正常运行，主线程也依次运行<br></p><h5 id="以下为对join函数的调用"><a href="#以下为对join函数的调用" class="headerlink" title="以下为对join函数的调用"></a>以下为对join函数的调用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Worker worker1=<span class="keyword">new</span> Worker(<span class="string">"work-1"</span>);</span><br><span class="line">Worker worker2=<span class="keyword">new</span> Worker(<span class="string">"work-2"</span>);</span><br><span class="line">worker1.start();</span><br><span class="line">System.out.println(<span class="string">"启动线程1"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">worker1.join();</span><br><span class="line">System.out.println(<span class="string">"启动线程2"</span>);</span><br><span class="line">worker2.start();</span><br><span class="line">worker2.join();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"work in "</span>+getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><blockquote></blockquote><p>启动线程-1<br>work in work-1<br>启动线程-2<br>work in work-2</p><p>由于使用join机制，使得线程不得不挨个运行，主线程内先执行worker1.start()方法，此次work1执行，随后立即调用work1的join方法，导致主线程拥塞，优先执行work1线程，依次类推work2线程处理方式也一样。为了方便理解，对调用join函数部分使用注释，以下为修改后的结果：<br></p><blockquote></blockquote><p>启动线程1<br>启动线程2<br>work in work-2<br>work in work-1<br><strong>Notes:此处work1和work2执行结束顺序不分先后</strong></p><h5 id="以下为对join函数的调用-1"><a href="#以下为对join函数的调用-1" class="headerlink" title="以下为对join函数的调用"></a>以下为对join函数的调用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">YieldThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">YieldThread</span><span class="params">(String  name)</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">System.out.println(<span class="keyword">this</span>.getName()+<span class="string">" "</span>+<span class="keyword">this</span>.getPriority()+<span class="string">"---&gt;"</span>+i);</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">2</span>)&#123;</span><br><span class="line">Thread.yield();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">YieldThread t1=<span class="keyword">new</span> YieldThread(<span class="string">"thread-1"</span>);</span><br><span class="line">YieldThread t2=<span class="keyword">new</span> YieldThread(<span class="string">"thread-2"</span>);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p>thread-1 5—&gt;0<br>thread-1 5—&gt;1<br>thread-1 5—&gt;2<br>thread-2 5—&gt;0<br>thread-2 5—&gt;1<br>thread-2 5—&gt;2<br>thread-1 5—&gt;3<br>thread-1 5—&gt;4<br>thread-2 5—&gt;3<br>thread-2 5—&gt;4<br><em>Notes:由于t1,t2运行先后顺序不确定，导致运行结果不唯一，截取显示的为最易功能分析的结果</em></p><p>对上述代码分析可以得出，run函数内部对i的情形进行判断，如果i为2时，则当前线程让出执行，让另一线程优先执行。即无论t1,t2谁的i值先到到2都会让出当前线程，让另一线程执行，当让出线程执行后i值也等于2时，则次线程也让出。随后则依次执行完各自线程的内容，即程序结束</p>]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android机制之Handler解析</title>
      <link href="/2018/08/01/Android%E6%9C%BA%E5%88%B6%E4%B9%8BHandler%E8%A7%A3%E6%9E%90/"/>
      <url>/2018/08/01/Android%E6%9C%BA%E5%88%B6%E4%B9%8BHandler%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h4 id="Android中的消息机制"><a href="#Android中的消息机制" class="headerlink" title="Android中的消息机制"></a>Android中的消息机制</h4><h4 id="处理消息的手段—Handler，Looper与MessageQueue："><a href="#处理消息的手段—Handler，Looper与MessageQueue：" class="headerlink" title="处理消息的手段—Handler，Looper与MessageQueue："></a>处理消息的手段—Handler，Looper与MessageQueue：</h4><p>Android应用启动时，存在一个默认主线程(UI线程)，该线程会关联一个消息队列，所有操作被封装成消息交给主流策划功能来处理。保证不退出，将消息操作置入一个<strong>死循环</strong>中，程序就一直运行，因此不会退出。<br><br><img src="http://img.blog.csdn.net/20170712221816133?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZW5vdWdoX2VtcHR5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>UI线程的消息循环实在ActivityThread.main方法中创建的，函数源代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  <span class="comment">//代码省略</span></span><br><span class="line">  Process.setArgV0(<span class="string">"&lt;pre-initialized&gt;);</span></span><br><span class="line"><span class="string">  Looper.perpareMainLooper();  //创建消息循环Looper</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  ActivityThread thread =new ActivityThread();</span></span><br><span class="line"><span class="string">  thread.attach(false);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  if(sMainThreadHandler == null)&#123;</span></span><br><span class="line"><span class="string">    sMainThreadHandler=thread.getHandler(); //此处获取UI线程的Handler</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  AsyncTask.init();</span></span><br><span class="line"><span class="string">  //代码省略</span></span><br><span class="line"><span class="string">  Looper.loop(); //2.执行消息循环</span></span><br><span class="line"><span class="string">  throw new RuntimeException("</span>Main thread loop uexpectedly exited<span class="string">");</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p><p>在子线程中执行耗时操作后需要更新UI，则此时的手段就是通过Handler将消息Post到UI线程中(mHandler.sendEmptyMessage(msg))，然后在Handler中的handleMessage方法进行处理。<br><br><strong>实例代码如下:</strong><br>Post操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MyHandler mHandler = <span class="keyword">new</span> MyHandler();</span><br><span class="line"><span class="comment">//开启新线程</span></span><br><span class="line"><span class="keyword">new</span> Thread()&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//耗时操作</span></span><br><span class="line">    mHandler.sendEmptyMessage(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>UI线程处理:(该Handler必须在主线程中创建才可更新UI)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>&#123;</span><br><span class="line">    <span class="comment">//更新UI</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Notes：</strong></p><ul><li>每个<strong>Handler</strong>都关联一个<strong>消息队列</strong>，<strong>消息队列</strong>封装在<strong>Looper</strong>中，每个<strong>Looper</strong>又需要关联一个<strong>线程</strong>（Looper通过ThreadLocal封装），即等于每个<strong>消息队列</strong>又关联一个<strong>线程</strong>。</li><li>默认情况下，<strong>消息对象</strong>只有一个，即主线程的消息队列，该消息队列在<strong>ActivityThread.main</strong>中创建。通过<strong>Looper.perpareMainLooper()</strong>创建，最后执行<strong>Looper.loop()</strong>启动消息队列<strong>循环</strong></li></ul><p>Handler关联消息队列以及线程源代码解析：<br><em>handler.java</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无参数构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//含Callback与async的参数构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">  mLooper = Looper.myLooper();  <span class="comment">//获取Looper</span></span><br><span class="line">  <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">          <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  mQueue = mLooper.mQueue;  <span class="comment">//获取消息队列</span></span><br><span class="line">  mCallback = callback;</span><br><span class="line">  mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Handler通过Looper.myLooper()获取Looper对象，建立关联，接着对ActivityThread.main方法中调用的Looper.perpareMainLooper()方法进行分析：<br><em>Looper.java</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建ThreadLocal对象</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置UI线程Looper</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  prepare(<span class="keyword">false</span>);  <span class="comment">//为当前线程准备一个Looper</span></span><br><span class="line">  <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">      <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      sMainLooper = myLooper();  <span class="comment">//为主线程设置Looper</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为当前线程设置Looper</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前线程Looper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对上述<em>Looper.java</em>源码进行分析，即可得到，系统执行ActivityThread.main方法创建主线程消息循环。main方法中执行perpareMainLooper()方法设置UI线程的Looper，此时Looper对象不存在，执行prepare()方法，通过sThreadLocal.set(new Looper(quitAllowed))方法将新创建的Looper对象与当前线程sThreadLocal关联。此时即完成了消息队列与线程的关联。但是此时存在一个问题，我们无法了解sThreadLocal是否为我们所需要绑定的线程值。接下来对ThreadLocal.java源代码进行分析：<br><em>ThreadLocal.java</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">//省略其他代码</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> (T)e.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对上述源代码进行分析，T为泛型，从get方法中的第一个行即可看出此方法为获取当前线程值，对结果进行返回。由此可知在<em>Looper.java</em>中对sThreadLocal进行声明与创建，在执行sThreadLocal = new ThreadLocal<looper>()方法后，sThreadLocal值已经获取了当前线程值。此时即可说明消息队列与线程的成功关联。而从当前机制即可说明，不同的线程有不同的消息队列，不能随意访问。<br></looper></p><p>此时继续对Handler分析，消息队列通过Looper与线程关联上，而Handler又与Looper关联，因此，Handler最终就和线程，线程的消息队列关联成功。只有更新UI的Handler在主线程中创建，handleMessage在会在UI线程中执行。</p><p>创建Looper成功后，需要执行消息循环，而消息循环的建立通过Looper.loop()方法，源代码核心部分如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">  <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> MessageQueue queue = me.mQueue;  <span class="comment">// 1.获取消息队列</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;  <span class="comment">// 2.死循环</span></span><br><span class="line">   Message msg = queue.next();  <span class="comment">// 3.依次获取消息</span></span><br><span class="line">     <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//代码省略</span></span><br><span class="line">    msg.target.dispatchMessage(msg);  <span class="comment">// 4.处理消息</span></span><br><span class="line">    <span class="comment">//代码省略</span></span><br><span class="line">    msg.recycleUnchecked();  <span class="comment">// 5.回收消息</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上述程序中可以得出，loop方法中实质就是建立一个死循环，通过消息队列一次取出消息，最后处理消息的过程。对Looper进行总结，通过Looper.perpare()创建Looper对象，且保存在sThreadLocal中，通过Looper.loop()来执行消息循环。这两步通常成对出现，缺一不可。</p><p>最后分析消息处理机制，从上述代码中第4步通过msg.target.dispatchMessage(msg)来处理消息。其中msg为Message类型，源代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Parcelable</span></span>&#123;</span><br><span class="line">  Handler target;  <span class="comment">// target处理</span></span><br><span class="line">  Runnable callback;  <span class="comment">// Runnable类型的callback</span></span><br><span class="line">  Message next;  <span class="comment">// 下一条消息，消息队列是链式存储</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//代码省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从源代码中可以看出，target是Handler类型。实际上仍旧是通过Handler将消息投递给消息队列，消息队列又将消息分发给Handler来处理。接下来继续从源代码进行分析：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消息处理函数，子类覆写</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message msg)</span></span>&#123;</span><br><span class="line">  msg.callback.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消息分发</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>)&#123;</span><br><span class="line">    handleCallback(msg);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span> (mCallback.handleMessage(msg))&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handleMessage(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上述程序中可以看到，dispatchMessage只是一个分发的方法，如果Runnable类型的callback为空，则执行handleMessage处理消息，该方法为空，则将更新UI的代码写在该函数中；如果callback不为空，则执行handleCallback来处理，该方法调用callback的run方法。则其实是Handler分发的两种类型，比如我们post(Runnable callback)则 callback不为空，我们使用Handler使用sendMessage时通常不会社会资callback，因此，就执行handleMessage这个分支。实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">  Message m = Message.obtain();</span><br><span class="line">  m.callback = r;</span><br><span class="line">  <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    delayMillis = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">  MessageQueue queue = mQueue;</span><br><span class="line">  <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">     RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">          <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">            Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上述代码可以看出，在post(Runnable r)时，会将Runnable包装成Message对象，并且将Runnable对象设置给Message对象的callback字段，最后将该Message对象插入消息队列。</p><p>无论是post一个Runnable还是Message，都会调用sendMessageDelayed(msg,time)方法。Handler最终将消息追加到MessageQueue中，而Looper不断的从MessageQueue中读取消息，并调用Handler的dispatchMessage消息，此时消息会源源不断的产生，添加到MessageQueue中。Android应用就成功运转了</p><p><strong>Notes:</strong>创建Handler之前先执行Looper.perpare(),然后添加Looper.loop().否则将会出现错误.<br>正确演示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread()&#123;</span><br><span class="line">  Handler handler =<span class="keyword">null</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Looper.prepare();</span><br><span class="line">    handler=<span class="keyword">new</span> Handler();</span><br><span class="line">    Looper.loop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android四大组件之Activity详解</title>
      <link href="/2018/08/01/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8BActivity%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/08/01/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8BActivity%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h4 id="Activity生命周期："><a href="#Activity生命周期：" class="headerlink" title="Activity生命周期："></a>Activity生命周期：</h4><p><img src="http://img.blog.csdn.net/20170711120007533?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZW5vdWdoX2VtcHR5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>onCreate：在Acitivty第一次创建时调用，用于做初始化的工作<br>onStart：onCreate调用后调用，此次界面对用户来说无法看见<br>onResume：此次界面可见并显示到前台，且当前Acitvity位于当前栈顶，并且处于运行状态<br>onPause：表示当前Activity正在停止，常做一些存储数据、停止动画等工作(不做耗时操作)<br>onStop：表示当前Activity即将停止，一般做微量级的回收工作<br>onDestory：表示当前Activity即将被销毁，可做一些回收工作和最终的资源释放<br>onRestart：表示当前Activity正在重新启动，当前Activity从不可见状态变化为可见状态  </p><h4 id="Activity的构成"><a href="#Activity的构成" class="headerlink" title="Activity的构成"></a>Activity的构成</h4><p><img src="http://img.blog.csdn.net/20170711115955775?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZW5vdWdoX2VtcHR5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>PhoneWindow是Window的实现类，而Window之下包含一个DecorView，DecorView实际是页面的顶级视图，开发是设置的布局资源添加到系统布局的mContentParent中，android解析XML方法（SAX、Pull、Dom三种方式）</p><h4 id="Activity的四种启动模式-standard-singleTop-singleTask-singleInstance"><a href="#Activity的四种启动模式-standard-singleTop-singleTask-singleInstance" class="headerlink" title="Activity的四种启动模式(standard,singleTop,singleTask,singleInstance)"></a>Activity的四种启动模式(standard,singleTop,singleTask,singleInstance)</h4><p>1：standard(标准启动模式)栈内允许有多个实例，互不影响<br>2：singleTop 当以singleTop为启动模式的Activity再次启动时，如果当前已经有一个实例位于栈顶，当再次调用原来的onNewIntent()函数，栈顶不会新加入一个实例。如果实例不在栈顶，则与standard标准启动一样<br>3：singleTask 如果一个Activity设置了该启动模式，任务栈中只能存在一个该Activity的实例。如果任务栈中存在一个Activity实例，则销毁当前Activity栈内位于实例之前的所有Activity实例，最终让该Activity实例位于栈顶。同时调用该Activity的onNewIntent()函数<br>4：singleInstance 设置singleInstance模式的Activity会在一个单独的任务栈中开启实例，当再次启动该Activity实例时，会重用已存在的任务与实例，并调用该实例的onNewIntent()函数，将intent实例中传递到该实例中</p><p><strong>Note:</strong>（仍旧将任务栈中X前的实例全部取消）</p><p>  对于singleTask作为启动模式的实例X，有选择其所需要的任务栈，例如本身主任务栈为S1,且当前任务栈中不存在X实例，若所需要的任务栈为S2，且任务栈S2不存在，则创建S2与X实例，并将实例X存入栈S2中<br>  另一种情况下，假设X所需的任务栈为S1，其他情况如上述例子所示，由于S1任务栈已经存在，所以系统会直接创建X的实例并将其导入栈S1中</p><p><strong>设置启动模式方法：</strong></p><p>第一种：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity</span><br><span class="line">    android:name=<span class="string">"com.sample.sampleActivity"</span></span><br><span class="line">    android:launchMode=<span class="string">"singleTask"</span></span><br><span class="line">    android:label=<span class="string">"@string/app_name"</span>/&gt;</span><br></pre></td></tr></table></figure></p><p>第二种：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent intent=<span class="keyword">new</span> Intent();</span><br><span class="line">intent.setClass(MainActivity.<span class="keyword">this</span>,sampleActivity.class);</span><br><span class="line">intent.addFalgs(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure></p><p><strong>Notes:</strong> 第一种无法直接为Activity设定FALG_ACTIVITY_CLEAR_TOP表示，而第二种方式无法为Activity指定singleInstance模式</p><h4 id="Activity的Flags"><a href="#Activity的Flags" class="headerlink" title="Activity的Flags"></a>Activity的Flags</h4><ul><li>FALG_ACTIVITY_NEW_TASK（对应Activity的singletask启动模式）</li><li>FALG_ACTIVITY_SINGLE_TOP （对应Activity的singletop启动模式）</li><li>FALG_ACTIVITY_CLEAR_TOP（具有次标记的Activity，当他启动时，在同一任务栈中所有位于它上面的Activity都要出栈，一般与singleTask启动模式一起出现，如果启动的实例已经存在，系统就会调用onNewIntent）</li><li>FALG_ACTIVITY_EXCLUDE_FROM_RESCENTS（具有这个标记的Activity不会出现在历史的Activity的列表中，等同与android:excludeFromRecents=”true”）</li></ul><h4 id="异常情况下的生命周期分析"><a href="#异常情况下的生命周期分析" class="headerlink" title="异常情况下的生命周期分析"></a>异常情况下的生命周期分析</h4><p><img src="http://img.blog.csdn.net/20170711115934148?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZW5vdWdoX2VtcHR5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>1、情况1：资源相关的系统配置发生改变导致Activity被杀死并重新创建<br>横竖屏突然转换，在默认情况下，Activity就会被销毁并且重新创建，系统先调用onSaveInstanceSate来保存当前Activity的状态。该方法调用在onStop之前，与onPause没有时序关系。当Activity在被重新创建之后，系统会调用onRestoreInstanceSate和onCreate方法来判断Activity是否被创建了，如果被重建了，那么我们就可以取出之前保存的数据并恢复，从时序上来说，onRestoreInstanceSate的调用在onStart上。类似TextView源码中包含onSaveInstanceSate方法保存控件内容。在AndroidManifest文件中设置android:configChanges=”orientation”保证屏幕方向固定，此时即使手机旋转界面仍旧保持原来方向不发生改变<br></p><p>2、情况2：Activity按照优先级从高到低，可以分为如下三种<br>(1) 前台Activity—正在和用户交互的Activity，优先级最高<br>(2) 可见但非前台Activity—比如Activity中弹出一个对话框，则背后的Activity就是属于这种情况，可见但位于后台无法与用户直接交互<br>(3) 后台Activity—已经被暂停的Activity，比如执行了onStop，优先级最低。</p>]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git添加SSH Key</title>
      <link href="/2018/08/01/Git%E6%B7%BB%E5%8A%A0SSH-Key/"/>
      <url>/2018/08/01/Git%E6%B7%BB%E5%8A%A0SSH-Key/</url>
      <content type="html"><![CDATA[<p>1：设置姓名和邮箱地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;username&quot;</span><br><span class="line">git config --global user.email &quot;youremail@email.com&quot;</span><br></pre></td></tr></table></figure></p><p>2:设置SSH Key<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail@email.com&quot;</span><br></pre></td></tr></table></figure></p><p>输入密码后进入C:\Users\boy.ssh查看id_rsa.pub内的内容并且复制</p><p>or</p><p>输入 cat ~/.ssh/id_rsa.pub直接查看内容复制</p><p>3：进入github设置控制板添加ssh key，输入以下指令测试是否成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></p><p>如果出现”Hi username! You’ve successfully …”即为成功</p>]]></content>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android基础之Intent篇</title>
      <link href="/2018/08/01/Android%E5%9F%BA%E7%A1%80%E4%B9%8BIntent%E7%AF%87/"/>
      <url>/2018/08/01/Android%E5%9F%BA%E7%A1%80%E4%B9%8BIntent%E7%AF%87/</url>
      <content type="html"><![CDATA[<h3 id="无返回值："><a href="#无返回值：" class="headerlink" title="无返回值："></a>无返回值：</h3><p><strong>MainActivity.class</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>,TargetAcitvity.class);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure></p><p>or</p><p><strong>AndroidManifest.xml</strong><br>设置&lt;intent-filter&gt;<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity</span><br><span class="line">    android:name=<span class="string">".TargetAcitvity"</span> &gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=<span class="string">"personal_label"</span> /&gt;</span><br><span class="line">        &lt;category android:name=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure></p><p><strong>MainActivity.class</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setAction(<span class="string">"personal_label"</span>);</span><br><span class="line">intent.addCategory(<span class="string">"android.intent.category.DEFAUL"</span>);</span><br></pre></td></tr></table></figure></p><h3 id="携带传输数据："><a href="#携带传输数据：" class="headerlink" title="携带传输数据："></a>携带传输数据：</h3><p><strong>MainActivity</strong><br>在新建Intent对象时对Intent对象调用putExtra(key,content)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent=<span class="keyword">new</span> Intent(<span class="keyword">this</span>,TargetAcitvity.class);</span><br><span class="line">intent.putExtra(<span class="string">"test"</span>,<span class="string">"test"</span>);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure></p><p><strong>TargetAcitvity</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_me);</span><br><span class="line">    <span class="comment">//获取数据</span></span><br><span class="line">    Intent intent = getIntent();</span><br><span class="line">    String account=intent.getStringExtra(<span class="string">"account"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>返回值类型</strong></p><p><strong>MainActivity</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(RegisterActivity.<span class="keyword">this</span>,TargetAcitvity.class);</span><br><span class="line">startActivityForResult(intent, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);   </span><br><span class="line">    <span class="keyword">if</span>(resultCode==<span class="number">2</span>)&#123;  </span><br><span class="line">        <span class="keyword">if</span>(requestCode==<span class="number">1</span>)&#123;</span><br><span class="line">            Log.i(<span class="string">"test"</span>,<span class="string">"test"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>TargetAcitvity</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">setResult(<span class="number">2</span>, intent);</span><br><span class="line">finish();</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Andorid使用ksoap2进行WebService通信</title>
      <link href="/2018/08/01/Andorid%E4%BD%BF%E7%94%A8ksoap2%E8%BF%9B%E8%A1%8CWebService%E9%80%9A%E4%BF%A1/"/>
      <url>/2018/08/01/Andorid%E4%BD%BF%E7%94%A8ksoap2%E8%BF%9B%E8%A1%8CWebService%E9%80%9A%E4%BF%A1/</url>
      <content type="html"><![CDATA[<p>WebService 是一种基于SOAP协议的远程调用标准。通过WebService可以将不同操作系统平台，不同语言、不同技术整合到一起。在Android SDK中并没有提供调用WebService的库，因此，需要使用第三方类库（KSOAP2）来调用WebService。</p><p>示例代码分为两部分，android端与Web端（Android studio，VS2015）</p><ul><li><strong>Web端</strong></li></ul><p>使用VS创建一个新项目，选择Visual C# –&gt; web –&gt;ASP.NET Web应用程序，在资源管理器中打开后缀为.asmx文件进行修改</p><p><strong>代码部分：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">namespace WebService1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/// &lt;summary&gt;</span></span><br><span class="line">    <span class="comment">/// WebService1 的摘要说明</span></span><br><span class="line">    <span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line">    [WebService(Namespace = <span class="string">"http://tempuri.org/"</span>)]</span><br><span class="line">    [WebServiceBinding(ConformsTo = WsiProfiles.BasicProfile1_1)]</span><br><span class="line">    [System.ComponentModel.ToolboxItem(<span class="keyword">false</span>)]</span><br><span class="line">    <span class="comment">// 若要允许使用 ASP.NET AJAX 从脚本中调用此 Web 服务，请取消注释以下行。 </span></span><br><span class="line">    <span class="comment">// [System.Web.Script.Services.ScriptService]</span></span><br><span class="line">    public class WebService1 : System.Web.Services.WebService&#123;</span><br><span class="line">        [WebMethod]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> string <span class="title">HelloWorld</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Hello"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        [WebMethod]</span><br><span class="line">        <span class="keyword">public</span> string[] EchoMessage(string msg1,string msg2)&#123;</span><br><span class="line">            string []name = &#123; msg1, msg2 &#125;;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>android端（在AndroidManifest文件中添加网络连接权限）</strong></li></ul><p>Android端demo分为三个文件:<strong>MainActivity.java</strong>,<strong>Nettask.java</strong>,<strong>Netsetting.java</strong></p><pre>MainActivity.java:加载布局文件提高测试效果Nettask.java：Ksoap2包的使用，进行网络通信Netsetting.java：网络通信基本设置信息</pre><p><strong>MainActivity.java主要代码展示:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initBtn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化按钮点击事件</span></span><br><span class="line">    View btnHelloWorld = <span class="keyword">this</span>.findViewById(R.id.btnHelloWorld);</span><br><span class="line">    btnHelloWorld.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            Map&lt;String, String&gt; values = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">            <span class="comment">//设置参数</span></span><br><span class="line">            values.put(<span class="string">"msg"</span>, <span class="string">"It's android data"</span>);</span><br><span class="line">            <span class="comment">//发出请求</span></span><br><span class="line">            Request(mNetSetting.getMethod_Hello());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    View btnEchoMessage = <span class="keyword">this</span>.findViewById(R.id.btnEchoMessage);</span><br><span class="line">    btnEchoMessage.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">            Map&lt;String, String&gt; values = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">            <span class="comment">//设置参数</span></span><br><span class="line">            values.put(<span class="string">"msg1"</span>, <span class="string">"It's android data one"</span>);</span><br><span class="line">            values.put(<span class="string">"msg2"</span>, <span class="string">"It's android data two"</span>);</span><br><span class="line">            <span class="comment">//发出请求</span></span><br><span class="line">            Request(mNetSetting.getMethod_Echo(), values);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Push Request for WebService</span></span><br><span class="line"><span class="comment">* 使用AsyncTask完成网络通信（直接放入主线程会直接报错）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">(Object... params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> AsyncTask&lt;Object, Object, String&gt;() &#123;</span><br><span class="line">        <span class="comment">//Change the Textview content</span></span><br><span class="line">        String txt=<span class="keyword">new</span> String();</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> String <span class="title">doInBackground</span><span class="params">(Object... params)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (params != <span class="keyword">null</span> &amp;&amp; params.length == <span class="number">2</span>) &#123;</span><br><span class="line">                txt= mNetTask.Distribute_WebService((String) params[<span class="number">0</span>],</span><br><span class="line">                        (Map&lt;String, String&gt;) params[<span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (params != <span class="keyword">null</span> &amp;&amp; params.length == <span class="number">1</span>) &#123;</span><br><span class="line">                txt= mNetTask.Distribute_WebService((String) params[<span class="number">0</span>], <span class="keyword">null</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(String result)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//在主页面的Textview显示返回信息</span></span><br><span class="line">            tvMessage.setText(<span class="string">"Information from Server : "</span> + txt);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;.execute(params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Nettask.java代码展示:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> NetSetting mNetSetting=<span class="keyword">new</span> NetSetting();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//initialize the Method in Package "ksoap2" and get the object form SoapSerializationEnvelope</span></span><br><span class="line">    <span class="comment">//初始化方法ksoap包中的方法（如果是单纯使用不需要明白下面的意思,类似一个模板的使用）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SoapSerializationEnvelope <span class="title">DoGet</span><span class="params">(String MethodName, Map&lt;String, String&gt; Params)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 1、Define the WebService Space name and Method</span></span><br><span class="line">        SoapObject request = <span class="keyword">new</span> SoapObject(mNetSetting.getNamespace()  , MethodName);</span><br><span class="line">        <span class="comment">//Set the Method's parameter if not exists then ignore it</span></span><br><span class="line">        <span class="comment">//获取从MainActivity内的request方法中的参数，以及参数类型</span></span><br><span class="line">        <span class="keyword">if</span> (Params != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Iterator iter = Params.entrySet().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                Map.Entry entry = (Map.Entry) iter.next();</span><br><span class="line">                request.addProperty((String) entry.getKey(),</span><br><span class="line">                        (String) entry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            *   3、Create and use Webservice method to generate soap request</span></span><br><span class="line"><span class="comment">            *      parameter is the vserion name of Soap protocol and you can check it's Instructions to know it(eg:WebService1.asmx?WSDL)</span></span><br><span class="line"><span class="comment">            *   3、创建并且使用Webservice方法产生请求</span></span><br><span class="line"><span class="comment">            *      new SoapSerializationEnvelope(SoapEnvelope.VER12)方法中的VER12为soap协议的版本号</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        SoapSerializationEnvelope envelope = <span class="keyword">new</span> SoapSerializationEnvelope(</span><br><span class="line">                SoapEnvelope.VER12);</span><br><span class="line">        envelope.bodyOut = request;</span><br><span class="line">        <span class="comment">// when you use donet protocol then use true</span></span><br><span class="line">        envelope.dotNet = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//envelope为WEBSERVICE传输内容</span></span><br><span class="line">        HttpTransportSE http = <span class="keyword">new</span> HttpTransportSE(mNetSetting.getURL());</span><br><span class="line">        <span class="comment">// use call() to connect Server</span></span><br><span class="line">        <span class="comment">// call()方法实际为连接服务器</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            http.call(<span class="keyword">null</span>, envelope);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (HttpResponseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (XmlPullParserException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> envelope;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Change Method according to the MethodName</span></span><br><span class="line">    <span class="comment">//根据请求选择不同的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">Distribute_WebService</span><span class="params">(String MethodName, Map&lt;String, String&gt; Params)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(MethodName.equals(mNetSetting.getMethod_Hello()))</span><br><span class="line">            <span class="keyword">return</span> Hello_CallWebService(MethodName,Params);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Echo_CallWebService(MethodName,Params);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Hello_CallWebService</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">Hello_CallWebService</span><span class="params">(String MethodName, Map&lt;String, String&gt; Params)</span> </span>&#123;</span><br><span class="line">        SoapSerializationEnvelope envelope=DoGet(MethodName,Params);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//单个数据选择SoapPrimitive</span></span><br><span class="line">            <span class="keyword">final</span> SoapPrimitive result = (SoapPrimitive) envelope.getResponse();</span><br><span class="line">            <span class="keyword">if</span> (result!= <span class="keyword">null</span>) &#123;</span><br><span class="line">                Log.d(<span class="string">"----ReceivedMessage----"</span>, result.toString());</span><br><span class="line">                <span class="keyword">return</span> result.toString();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SoapFault e) &#123;</span><br><span class="line">            Log.e(<span class="string">"----WrongMessage---"</span>, e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Echo_CallWebService</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">Echo_CallWebService</span><span class="params">(String MethodName, Map&lt;String, String&gt; Params)</span> </span>&#123;</span><br><span class="line">        SoapSerializationEnvelope envelope=DoGet(MethodName,Params);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//复杂数据选择SoapObject</span></span><br><span class="line">            <span class="keyword">final</span> SoapObject result = (SoapObject) envelope.getResponse();</span><br><span class="line">            <span class="keyword">if</span> (result!= <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//通过使用getProperty()方法可以实现调用传输过来的方法</span></span><br><span class="line">                Log.d(<span class="string">"----ReceivedMessage----"</span>, result.getProperty(<span class="number">0</span>).toString());</span><br><span class="line">                Log.d(<span class="string">"----ReceivedMessage----"</span>, result.getProperty(<span class="number">1</span>).toString());</span><br><span class="line">                <span class="keyword">return</span> result.toString();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SoapFault e) &#123;</span><br><span class="line">            Log.e(<span class="string">"----WrongMessage---"</span>, e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Netsetting.java:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetSetting</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NetSetting</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Method Name 值与Web端相应方法的值必须保持一致</span></span><br><span class="line">    <span class="keyword">final</span> String METHOD_HELLO_WORLD = <span class="string">"HelloWorld"</span>;</span><br><span class="line">    <span class="keyword">final</span> String METHOD_ECHO_MESSAGE = <span class="string">"EchoMessage"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Server Url</span></span><br><span class="line">    <span class="keyword">final</span> String WEB_SERVICE_URL = <span class="string">"http://ip/WebService1.asmx"</span>;</span><br><span class="line">    <span class="comment">//WebService Space Name</span></span><br><span class="line">    <span class="keyword">final</span> String Namespace = <span class="string">"http://tempuri.org/"</span>;</span><br><span class="line">    <span class="comment">//Get Space Name</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getNamespace</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Namespace;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Get WebService Url</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getURL</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> WEB_SERVICE_URL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Get Mthod Name "HelloWorld"</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMethod_Hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> METHOD_HELLO_WORLD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Get Mthod Name "EchoMessage"</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMethod_Echo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> METHOD_ECHO_MESSAGE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里为全代码的demo地址<br><a href="http://download.csdn.net/detail/enough_empty/9628832" target="_blank" rel="noopener">http://download.csdn.net/detail/enough_empty/9628832</a><br>git 地址<br><a href="https://github.com/yclog/ksoap2-webservice-demo" target="_blank" rel="noopener">https://github.com/yclog/ksoap2-webservice-demo</a></p><p>参考博客<br>还是你最好:<a href="http://www.cnblogs.com/gzggyy/archive/2011/06/21/2086140.html" target="_blank" rel="noopener">http://www.cnblogs.com/gzggyy/archive/2011/06/21/2086140.html</a></p><p><strong>Ps:博主使用了各种手段设置WEB_SERVICE_URL中的IP都以android端连接失败告终，最后因为时间关系强行将web服务发布到服务器上，才解决了这个问题<br>之前尝试改为<a href="http://10.0.2.2/WebService1.asmx" target="_blank" rel="noopener">http://10.0.2.2/WebService1.asmx</a> 仍旧存在问题，如果有博友在本地成功希望能留下评论交流，谢谢</strong> </p>]]></content>
      
      
        <tags>
            
            <tag> Android, WebService </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>centos+wordpress搭建博客</title>
      <link href="/2018/07/31/centos-wordpress%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2018/07/31/centos-wordpress%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p>此教程使用wordpress（世界上最大的博客系统）搭建网站。相信即便是小白也能搭建出自己喜欢的网站。</p><p>要搭建自己的博客网站，首先要进行购买vps，如果打算用服务器顺带搭建VPN的话可以使用国外服务器进行搭建博客，国内最好的云服务提供商是阿里云，费用略贵一些，但安全性以及性能来说都是其他几家不能达到的。免费主机比较出名的有主机公园，注册即可以使用一年免费的云服务器。国外vps性能最好的是linode，不过需要visa卡进行注册购买，另一个性价比相当高的vps供应商是digital ocean，本供应商具有较多优惠，获取优惠链接<a href="http://blog.csdn.net/enough_empty/article/details/51334963" target="_blank" rel="noopener">digital ocean</a></p><p>国内购买域名主要有新网与万网两个大型域名购买网站， 但购买域名需要备案，故推荐<a href="https://sg.godaddy.com/zh/，全球最大域名网站，现在也支持支付宝付账了，一个.com域名价格大概在50RMB左右，不过需要使用godaddy的优惠券，这些都是很容易在网上找到的。" target="_blank" rel="noopener">https://sg.godaddy.com/zh/，全球最大域名网站，现在也支持支付宝付账了，一个.com域名价格大概在50RMB左右，不过需要使用godaddy的优惠券，这些都是很容易在网上找到的。</a></p><p>godaddy提供的域名服务器没有放置在国内，有可能会被查封dns无法解析域名，推荐使用dnspod进行域名解析。<br><img src="http://img.blog.csdn.net/20160418161400646" alt="这里写图片描述"></p><p>解析域名之后，添加自有服务器的IP，选择@主机记录</p><p><img src="http://img.blog.csdn.net/20160418161827685" alt="这里写图片描述"></p><p>设置好IP之后进入godaddy的dns管理页面更改原有域名服务器即可</p><p><img src="http://img.blog.csdn.net/20160418162001359" alt="这里写图片描述"></p><p><strong>接下来对vps进行操作</strong></p><p><strong>1.使用yum安装 mysql、apache、php</strong></p><p>登陆你的linux系统，在shell窗口输入以下命令：</p><p>yum -y install mysql-server httpd php php-mysql unzip wget</p><p>添加mysql、apache服务</p><p>chkconfig httpd on<br>chkconfig mysqld on</p><p>启动服务</p><p>service mysqld start<br>service httpd start</p><p><strong>2. 为wordpress创建数据库、用户名</strong></p><p>设置mysql root 密码 执行/usr/bin/mysql_secure_installation，按提示完成操作，设置root密码等</p><p>登录mysql：mysql -uroot -p</p><p>创建WordPress数据库：CREATE DATABASE wordpress;</p><p>创建WordPress用户： GRANT ALL PRIVILEGES ON <em>.</em> TO ‘用户名‘@localhost IDENTIFIED BY ‘用户密码’ WITH GRANT OPTION;   </p><p>FLUSH   PRIVILEGES; </p><p>刷新：FLUSH PRIVILEGES;</p><p>退出mysql：\q</p><p><strong>3. 下载wordpress跟安装</strong></p><p>cd /var/www/html</p><p>wget <a href="https://cn.wordpress.org/wordpress-4.5-zh_CN.zip（以后的版本可以去wordpress网站去找安装的下载连接即可）" target="_blank" rel="noopener">https://cn.wordpress.org/wordpress-4.5-zh_CN.zip（以后的版本可以去wordpress网站去找安装的下载连接即可）</a><br><img src="http://img.blog.csdn.net/20160418163023591" alt="这里写图片描述"></p><p>unzip wordpress-3.6.1zh_CN.zip<br>设置WordPress根目录owner<br>chown -R apache:apache wordpress<br><strong>将cd /var/www/html/wordpress内的所有文件移动到cd /var/www/html文件夹下</strong></p><p><strong>4. 配置wordpress</strong><br>cd /var/www/html  cp wp-config-sample.php    wp-config.php    </p><p>vi wp-config.php加入一行：<br>define(‘FS_METHOD’, ‘direct’); （WP后台直接操作文件，不通过FTP）</p><p>define(‘DB_NAME’, ‘database_name_here’);（database_name_here 换成 wordpress）<br>define(‘DB_USER’, ‘username_here’);（username_here 换成 wordpress）<br>define(‘DB_PASSWORD’, ‘password_here’);（password_here 换成 上面设置的 wordpress_password）</p><p>进入WordPress后台管理</p><p><a href="http://your-server-ip-or-hostname/wp-admin/install.php，进入这个页面进行安装，安装完毕后就能进去后台对博客系统进行管理了，如安装主题、插件等" target="_blank" rel="noopener">http://your-server-ip-or-hostname/wp-admin/install.php，进入这个页面进行安装，安装完毕后就能进去后台对博客系统进行管理了，如安装主题、插件等</a></p><p><a href="http://your-server-ip" target="_blank" rel="noopener">http://your-server-ip</a> 如果能进入这个页面表面你的wordpress博客系统已经成功搭建了</p><p>参考博客：<br>软件开发程序员博客文章收藏网：<a href="http://www.programgo.com/article/1874486129/" target="_blank" rel="noopener">http://www.programgo.com/article/1874486129/</a><br>季枫：<a href="http://www.cnblogs.com/jifeng/archive/2011/03/06/1972183.html" target="_blank" rel="noopener">http://www.cnblogs.com/jifeng/archive/2011/03/06/1972183.html</a></p><p>欢迎各位朋友对以上内容提出问题</p>]]></content>
      
      
        <tags>
            
            <tag> WordPress </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
