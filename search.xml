<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Android之多线程解析(二)之Runnable、Callable、FutureTask </title>
      <link href="/2018/08/01/Android%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%A7%A3%E6%9E%90-%E4%BA%8C-%E4%B9%8BRunnable%E3%80%81Callable%E3%80%81FutureTask/"/>
      <url>/2018/08/01/Android%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%A7%A3%E6%9E%90-%E4%BA%8C-%E4%B9%8BRunnable%E3%80%81Callable%E3%80%81FutureTask/</url>
      <content type="html"><![CDATA[<h4 id="与多线程相关的方法—Callable-Future以及FutureTask"><a href="#与多线程相关的方法—Callable-Future以及FutureTask" class="headerlink" title="与多线程相关的方法—Callable,Future以及FutureTask"></a>与多线程相关的方法—Callable,Future以及FutureTask</h4><p>除了上文中一直分析的Runnable之外，Java中还存在Callbale，Future，FutureTask与多线程相关的概念，与Runnable不同的则是这三个方法只能用于线程池中，Runnable则可以同时在运用在Thread和线程池中。<br></p><p>Callable与Runnable功能相似，不同在与Callable是一个泛型接口，他有一个泛型参数V，该接口中有一个返回值(类型为V)的call()函数，而Runnable的run函数不能将结果返回到客户程序中：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface Callable&lt;V&gt;&#123;</span><br><span class="line">//返回V类型的结果</span><br><span class="line">V call() throws Exception;</span><br><span class="line">&#125;</span><br><span class="line">//为加深理解，假如Runnable的源码作为对比</span><br><span class="line">public interface Runnable&#123;</span><br><span class="line">//返回V类型的结果</span><br><span class="line">public abstract void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>博客看到此处，即对Runnable以及Callable有了比较大致的了解，但是这两种机制存在着一个无法避免的缺陷，即一旦使用后就很难做到有效的控制。而Future的出现即解决了这种问题，Future为线程池制订了可管理的任务标准。Future提供了对Runnable或者Callable的任务的执行结果进行管理(取消，查询是否完成，获取结果，设置结果;分别对应着cancel,isDone,get,set函数，且get函数调用后会发生阻塞，直到执行完成返回结果)。Future声明如下：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public interface Future&lt;V&gt;&#123;</span><br><span class="line">boolean cancel(boolean mayInterruptIfRunning);</span><br><span class="line"></span><br><span class="line">boolean isCancelled();</span><br><span class="line"></span><br><span class="line">boolean isDone();</span><br><span class="line"></span><br><span class="line">V get() throws InterruptedException,ExecutionException;</span><br><span class="line"></span><br><span class="line">V get(long timeout,TimeUint unit)</span><br><span class="line">throws InterruptedException,ExecutionException,TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Future只是定义了一些规范的接口，FutureTask则是具体的实现类。FutureTask实现了RunnableFuture<v>，而RunnableFuture实现了Runnable又实现了Future<v>这两个接口，因此FutureTask同时具有两者的能力。FutureTask代码如下：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt;&#123;</span><br><span class="line">//代码省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></v></v></p><p>再看RunnabelFuture类定义：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class RunnabelFuture&lt;V&gt; implements Runnable,Future&lt;V&gt;&#123;</span><br><span class="line">void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>FutureTask会像Thread包装Runnable那样对Runnable和Callbale<v>进行包装，Runnbale与Callbale由构造函数注入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public FutureTask(Callable&lt;V&gt; callable)&#123;</span><br><span class="line">if(callable==null) throws new NullPointerException();</span><br><span class="line">this.callable=callable;</span><br><span class="line">this.state=NEW;// ensure visibility of callable</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public FutureTask(Runnable runnable,V result)&#123;</span><br><span class="line">this.callable=Executors.callable(runnable,result);</span><br><span class="line">this.state=NEW;// ensure visibility of callable</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></v></p><p>由上述代码即可看出，无论在构造函数中传输runnable或callable对象，都会被转换为callable对象，即可知道最终都是对Callable对象进行操作，该适配函数的实现如下：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task,T result)&#123;</span><br><span class="line">if(task==null) throws new NullPointerException();</span><br><span class="line">return new RunnableAdapter&lt;T&gt;(task,result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static final class RunnableAdapter&lt;T&gt; implements Callable&lt;T&gt;&#123;</span><br><span class="line">final Runnable task;</span><br><span class="line">final T result;</span><br><span class="line">RunnableAdapter(Runnable task,T result)&#123;</span><br><span class="line">this.task=task;</span><br><span class="line">this.result=result;</span><br><span class="line">&#125;</span><br><span class="line">public T call()&#123;</span><br><span class="line">task.run();</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于FutureTask实现了Runnable，因此它既可以通过Thread包装来直接执行，也可提交给ExecuteService来执行。且可直接通过get()获取执行结果，该函数会一直阻塞到结果返回。因此，FutureTask既是Future，Runnable，又包装了Callable，即为两者的合体<br><br>下面通过一个Java程序简单演示Runnable，Callable，FutureTask的运用：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public class FutureDemo &#123;</span><br><span class="line"></span><br><span class="line">static ExecutorService mExecutor=Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">try &#123;</span><br><span class="line">FutureWithRunnable();</span><br><span class="line">FutureWithCallable();</span><br><span class="line">FutureWithFutureTask();</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">// TODO: handle exception</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void FutureWithRunnable() throws InterruptedException,ExecutionException&#123;</span><br><span class="line">Future&lt;?&gt; result=mExecutor.submit(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">fibc(20);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(&quot;Future result from Runnable : &quot;+result.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void FutureWithCallable() throws InterruptedException,ExecutionException&#123;</span><br><span class="line">Future&lt;Integer&gt; result2=mExecutor.submit(new Callable&lt;Integer&gt;()&#123;</span><br><span class="line"></span><br><span class="line">public Integer call() throws Exception &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return fibc(20);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(&quot;Future result from Callable : &quot;+result2.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void FutureWithFutureTask() throws InterruptedException,ExecutionException&#123;</span><br><span class="line">FutureTask&lt;Integer&gt; futuretask=new FutureTask&lt;Integer&gt;(</span><br><span class="line">new Callable&lt;Integer&gt;() &#123;</span><br><span class="line">public Integer call() throws Exception &#123;</span><br><span class="line">return fibc(20);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">mExecutor.submit(futuretask);</span><br><span class="line">System.out.println(&quot;Future result from FutureTask : &quot;+futuretask.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static int fibc(int num)&#123;</span><br><span class="line">if(num == 0)</span><br><span class="line">return 0;</span><br><span class="line">if(num == 1)</span><br><span class="line">return 1;</span><br><span class="line">return fibc(num-1)+fibc(num-2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果为：<br>Future result from Runnable : null<br>Future result from Callable : 6765<br>Future result from FutureTask : 6765</p><p>由上述示例代码以及结果可以看出，以Runnable作为对象的执行后的结果无法通过get()函数方法获得。而使用Callable以及调用Callable的FutureTask可以通过get()函数获取执行后的结果。</p>]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android之多线程解析(一)之Thread、Runnable</title>
      <link href="/2018/08/01/Android%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%A7%A3%E6%9E%90-%E4%B8%80-%E4%B9%8BThread%E3%80%81Runnable/"/>
      <url>/2018/08/01/Android%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%A7%A3%E6%9E%90-%E4%B8%80-%E4%B9%8BThread%E3%80%81Runnable/</url>
      <content type="html"><![CDATA[<h4 id="多线程实现之Thread和Runnable"><a href="#多线程实现之Thread和Runnable" class="headerlink" title="多线程实现之Thread和Runnable"></a>多线程实现之Thread和Runnable</h4><p>Android的多线程实现最基础部分应该该为Thread和Runnable，通常情况下使用两种方式的启动方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void startNewThread()&#123;</span><br><span class="line">  new Thread()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">      //耗时操作</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>启动带Runnable参数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void startNewThread()&#123;</span><br><span class="line">  new Thread(new Runnable()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">      //耗时操作</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对示例一，实例二代码进行分析：实例一中代码使用Thread内的run函数执行操作，实例二中代码实际上为Thread的构造函数传递了一个Runnable对象，使用Runnable对象内的run方法执行耗时操作。两者之间的区别分析如下：<br></p><p><em>Thread源码如下：</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class Thread implements Runnable &#123;</span><br><span class="line">  //线程所属的ThreadGroup</span><br><span class="line">  private ThreadGroup group;</span><br><span class="line">  //需要执行的Runnable对象</span><br><span class="line">  private Runnable target;</span><br><span class="line"></span><br><span class="line">  public Thread() &#123;</span><br><span class="line">      init(null, null, &quot;Thread-&quot; + nextThreadNum(), 0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Thread(Runnable target) &#123;</span><br><span class="line">      init(null, target, &quot;Thread-&quot; + nextThreadNum(), 0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void init(ThreadGroup g, Runnable target, String name, long stackSize) &#123;</span><br><span class="line">      Thread parent = currentThread();</span><br><span class="line">      if (g == null) &#123;</span><br><span class="line">          g = parent.getThreadGroup();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      g.addUnstarted();</span><br><span class="line">      this.group = g;</span><br><span class="line"></span><br><span class="line">      this.target = target;</span><br><span class="line">      this.priority = parent.getPriority();</span><br><span class="line">      this.daemon = parent.isDaemon();</span><br><span class="line">      setName(name);</span><br><span class="line">      //代码省略</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //为了节约长度，只提取了核心代码进行处理</span><br><span class="line">  public synchronized void start() &#123;</span><br><span class="line">    if (threadStatus != 0)</span><br><span class="line">        throw new IllegalThreadStateException();</span><br><span class="line">    group.add(this);</span><br><span class="line">    nativeCreate(this, stackSize, daemon);</span><br><span class="line">    started = true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void run() &#123;</span><br><span class="line">      if (target != null) &#123;</span><br><span class="line">         target.run();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从官方源代码中对init函数功能描述为<em>初始化线程</em>，第一个参数ThreadGroup为线程组，第二个参数target为当前线程的Runnable对象。源码init函数功能注释为：<br></p><p><em>group threads created/set up by the VM. Any new functionality added to this method in the future may have to also be added to the VM.</em><br>中文对应翻译过来即为：<strong>线程组在Android的虚拟机中创建或者设置，任何新功能都能被添加到该方法中在以后将会被添加到Android的虚拟机中</strong>。<br></p><p>对上述代码中start函数进行分析，根据group.add(this)函数即为将当前线程添加到线程组中，依据Android虚拟机自行调度运行中。对源代码的run方法进行分析，当启动一个线程时，如果Thread的target不为空，则会在子线程汇总执行这个target的run方法。否则虚拟机将会执行线程自身的run函数。<br></p><h3 id="线程的wait，sleep，join和yield方法"><a href="#线程的wait，sleep，join和yield方法" class="headerlink" title="线程的wait，sleep，join和yield方法"></a>线程的wait，sleep，join和yield方法</h3><table><thead><tr><th>函数名</th><th>含义</th></tr></thead><tbody><tr><td>wait</td><td>线程执行后，进入到与对象相关的等待池中，同时释放了对象的机锁。使其他线            程可以访问，用户可以使用notify、notifyAll或者指定睡眠时间后唤醒</td></tr><tr><td>sleep</td><td>该函数为Thread的静态函数，使调用线程进入睡眠状态，由于是static方法， 所以无法改变对象的机锁。所以，当在一个synchronized块中调用sleep方法。虽然休眠了，但是对象的机制并没有释放，其他线程无法访问该对象</td></tr><tr><td>join</td><td>等待目标线程执行完成之后再继续执行</td></tr><tr><td>yield</td><td>线程礼让，目标线程由运行状态换为就绪状态，即让出执行权限，其他线程优先执行。其他线程是否能够优先执行不可知。</td></tr></tbody></table><p><br><br><em>Notes:为提高程序的可理解性，此处以及下面引入synchronized机制</em></p><h5 id="以下为对wait，notify与notifyAll的应用"><a href="#以下为对wait，notify与notifyAll的应用" class="headerlink" title="以下为对wait，notify与notifyAll的应用"></a>以下为对wait，notify与notifyAll的应用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">System.out.println(&quot;主线程运行&quot;);</span><br><span class="line">Thread thread=new WaitThread();</span><br><span class="line">thread.start();</span><br><span class="line">long starttime=System.currentTimeMillis();</span><br><span class="line">try &#123;</span><br><span class="line">synchronized (sLockObject) &#123;</span><br><span class="line">System.out.println(&quot;主线程等待&quot;);</span><br><span class="line">sLockObject.wait();</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">// TODO: handle exception</span><br><span class="line">&#125;</span><br><span class="line">long timeMs=(System.currentTimeMillis()-starttime);</span><br><span class="line">System.out.println(&quot;主线程继续--&gt;等待耗时：&quot;+timeMs+&quot; ms&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class WaitThread extends Thread&#123;</span><br><span class="line">public void run() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">try &#123;</span><br><span class="line">synchronized (sLockObject) &#123;</span><br><span class="line">Thread.sleep(3000);</span><br><span class="line">sLockObject.notifyAll();</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">// TODO: handle exception</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前运行结果为:</p><blockquote></blockquote><p>主线程运行<br>主线程等待<br>主线程继续–&gt;等待耗时：3001 ms</p><p>上述代码为，首先在主线程中synchronized块中调用wait方法，使WaitThread进入等待池，此时主线程停止运行，由于WaitThread中的synchronized块为设置睡眠时间为3秒，三秒后调用notifyAll()方法，使WaitThread线程正常运行，主线程也依次运行<br></p><h5 id="以下为对join函数的调用"><a href="#以下为对join函数的调用" class="headerlink" title="以下为对join函数的调用"></a>以下为对join函数的调用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Worker worker1=new Worker(&quot;work-1&quot;);</span><br><span class="line">Worker worker2=new Worker(&quot;work-2&quot;);</span><br><span class="line">worker1.start();</span><br><span class="line">System.out.println(&quot;启动线程1&quot;);</span><br><span class="line">try &#123;</span><br><span class="line">worker1.join();</span><br><span class="line">System.out.println(&quot;启动线程2&quot;);</span><br><span class="line">worker2.start();</span><br><span class="line">worker2.join();</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">// TODO: handle exception</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class Worker extends Thread&#123;</span><br><span class="line">public Worker(String name)&#123;</span><br><span class="line">super(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(2000);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">// TODO: handle exception</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;work in &quot;+getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><blockquote></blockquote><p>启动线程-1<br>work in work-1<br>启动线程-2<br>work in work-2</p><p>由于使用join机制，使得线程不得不挨个运行，主线程内先执行worker1.start()方法，此次work1执行，随后立即调用work1的join方法，导致主线程拥塞，优先执行work1线程，依次类推work2线程处理方式也一样。为了方便理解，对调用join函数部分使用注释，以下为修改后的结果：<br></p><blockquote></blockquote><p>启动线程1<br>启动线程2<br>work in work-2<br>work in work-1<br><strong>Notes:此处work1和work2执行结束顺序不分先后</strong></p><h5 id="以下为对join函数的调用-1"><a href="#以下为对join函数的调用-1" class="headerlink" title="以下为对join函数的调用"></a>以下为对join函数的调用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static class YieldThread extends Thread&#123;</span><br><span class="line">public YieldThread(String  name)&#123;</span><br><span class="line">super(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public synchronized void run()&#123;</span><br><span class="line">for(int i=0;i&lt;5;i++)&#123;</span><br><span class="line">System.out.println(this.getName()+&quot; &quot;+this.getPriority()+&quot;---&gt;&quot;+i);</span><br><span class="line">if(i==2)&#123;</span><br><span class="line">Thread.yield();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">YieldThread t1=new YieldThread(&quot;thread-1&quot;);</span><br><span class="line">YieldThread t2=new YieldThread(&quot;thread-2&quot;);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：<br></p><blockquote></blockquote><p>thread-1 5—&gt;0<br>thread-1 5—&gt;1<br>thread-1 5—&gt;2<br>thread-2 5—&gt;0<br>thread-2 5—&gt;1<br>thread-2 5—&gt;2<br>thread-1 5—&gt;3<br>thread-1 5—&gt;4<br>thread-2 5—&gt;3<br>thread-2 5—&gt;4<br><em>Notes:由于t1,t2运行先后顺序不确定，导致运行结果不唯一，截取显示的为最易功能分析的结果</em></p><p>对上述代码分析可以得出，run函数内部对i的情形进行判断，如果i为2时，则当前线程让出执行，让另一线程优先执行。即无论t1,t2谁的i值先到到2都会让出当前线程，让另一线程执行，当让出线程执行后i值也等于2时，则次线程也让出。随后则依次执行完各自线程的内容，即程序结束</p>]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android机制之Handler解析</title>
      <link href="/2018/08/01/Android%E6%9C%BA%E5%88%B6%E4%B9%8BHandler%E8%A7%A3%E6%9E%90/"/>
      <url>/2018/08/01/Android%E6%9C%BA%E5%88%B6%E4%B9%8BHandler%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h4 id="Android中的消息机制"><a href="#Android中的消息机制" class="headerlink" title="Android中的消息机制"></a>Android中的消息机制</h4><h4 id="处理消息的手段—Handler，Looper与MessageQueue："><a href="#处理消息的手段—Handler，Looper与MessageQueue：" class="headerlink" title="处理消息的手段—Handler，Looper与MessageQueue："></a>处理消息的手段—Handler，Looper与MessageQueue：</h4><p>Android应用启动时，存在一个默认主线程(UI线程)，该线程会关联一个消息队列，所有操作被封装成消息交给主流策划功能来处理。保证不退出，将消息操作置入一个<strong>死循环</strong>中，程序就一直运行，因此不会退出。<br><br><img src="http://img.blog.csdn.net/20170712221816133?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZW5vdWdoX2VtcHR5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><br><br>UI线程的消息循环实在ActivityThread.main方法中创建的，函数源代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">  //代码省略</span><br><span class="line">  Process.setArgV0(&quot;&lt;pre-initialized&gt;);</span><br><span class="line">  Looper.perpareMainLooper();  //创建消息循环Looper</span><br><span class="line"></span><br><span class="line">  ActivityThread thread =new ActivityThread();</span><br><span class="line">  thread.attach(false);</span><br><span class="line"></span><br><span class="line">  if(sMainThreadHandler == null)&#123;</span><br><span class="line">    sMainThreadHandler=thread.getHandler(); //此处获取UI线程的Handler</span><br><span class="line">  &#125;</span><br><span class="line">  AsyncTask.init();</span><br><span class="line">  //代码省略</span><br><span class="line">  Looper.loop(); //2.执行消息循环</span><br><span class="line">  throw new RuntimeException(&quot;Main thread loop uexpectedly exited&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在子线程中执行耗时操作后需要更新UI，则此时的手段就是通过Handler将消息Post到UI线程中(mHandler.sendEmptyMessage(msg))，然后在Handler中的handleMessage方法进行处理。<br><br><strong>实例代码如下:</strong><br><br>Post操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MyHandler mHandler = new MyHandler();</span><br><span class="line">//开启新线程</span><br><span class="line">new Thread()&#123;</span><br><span class="line">  public void run()&#123;</span><br><span class="line">    //耗时操作</span><br><span class="line">    mHandler.sendEmptyMessage(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>UI线程处理:(该Handler必须在主线程中创建才可更新UI)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class MyHandler extends Handler&#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void handleMessage(Message msg)&#123;</span><br><span class="line">    //更新UI</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>Notes：</strong></p><ul><li>每个<strong>Handler</strong>都关联一个<strong>消息队列</strong>，<strong>消息队列</strong>封装在<strong>Looper</strong>中，每个<strong>Looper</strong>又需要关联一个<strong>线程</strong>（Looper通过ThreadLocal封装），即等于每个<strong>消息队列</strong>又关联一个<strong>线程</strong>。</li><li>默认情况下，<strong>消息对象</strong>只有一个，即主线程的消息队列，该消息队列在<strong>ActivityThread.main</strong>中创建。通过<strong>Looper.perpareMainLooper()</strong>创建，最后执行<strong>Looper.loop()</strong>启动消息队列<strong>循环</strong></li></ul></blockquote><p>Handler关联消息队列以及线程源代码解析：<br><br><br><br><em>handler.java</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//无参数构造方法</span><br><span class="line">public Handler() &#123;</span><br><span class="line">        this(null, false);</span><br><span class="line">&#125;</span><br><span class="line">//含Callback与async的参数构造方法</span><br><span class="line">public Handler(Callback callback, boolean async) &#123;</span><br><span class="line">  mLooper = Looper.myLooper();  //获取Looper</span><br><span class="line">  if (mLooper == null) &#123;</span><br><span class="line">      throw new RuntimeException(</span><br><span class="line">          &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  mQueue = mLooper.mQueue;  //获取消息队列</span><br><span class="line">  mCallback = callback;</span><br><span class="line">  mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Handler通过Looper.myLooper()获取Looper对象，建立关联，接着对ActivityThread.main方法中调用的Looper.perpareMainLooper()方法进行分析：<br><br><br><br><em>Looper.java</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//创建ThreadLocal对象</span><br><span class="line">static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();</span><br><span class="line"></span><br><span class="line">//设置UI线程Looper</span><br><span class="line">public static void prepareMainLooper() &#123;</span><br><span class="line">  prepare(false);  //为当前线程准备一个Looper</span><br><span class="line">  synchronized (Looper.class) &#123;</span><br><span class="line">      if (sMainLooper != null) &#123;</span><br><span class="line">          throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      sMainLooper = myLooper();  //为主线程设置Looper</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//为当前线程设置Looper</span><br><span class="line">private static void prepare(boolean quitAllowed) &#123;</span><br><span class="line">  if (sThreadLocal.get() != null) &#123;</span><br><span class="line">      throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  sThreadLocal.set(new Looper(quitAllowed));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//获取当前线程Looper</span><br><span class="line">public static @Nullable Looper myLooper() &#123;</span><br><span class="line">  return sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对上述<em>Looper.java</em>源码进行分析，即可得到，系统执行ActivityThread.main方法创建主线程消息循环。main方法中执行perpareMainLooper()方法设置UI线程的Looper，此时Looper对象不存在，执行prepare()方法，通过sThreadLocal.set(new Looper(quitAllowed))方法将新创建的Looper对象与当前线程sThreadLocal关联。此时即完成了消息队列与线程的关联。但是此时存在一个问题，我们无法了解sThreadLocal是否为我们所需要绑定的线程值。接下来对ThreadLocal.java源代码进行分析：<br><br><br><br><em>ThreadLocal.java</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadLocal&lt;T&gt; &#123;</span><br><span class="line">  //省略其他代码</span><br><span class="line">  public T get() &#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        if (map != null) &#123;</span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class="line">            if (e != null)</span><br><span class="line">                return (T)e.value;</span><br><span class="line">        &#125;</span><br><span class="line">        return setInitialValue();</span><br><span class="line">    &#125;</span><br><span class="line">    //省略其他代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对上述源代码进行分析，T为泛型，从get方法中的第一个行即可看出此方法为获取当前线程值，对结果进行返回。由此可知在<em>Looper.java</em>中对sThreadLocal进行声明与创建，在执行sThreadLocal = new ThreadLocal<looper>()方法后，sThreadLocal值已经获取了当前线程值。此时即可说明消息队列与线程的成功关联。而从当前机制即可说明，不同的线程有不同的消息队列，不能随意访问。<br></looper></p><p>此时继续对Handler分析，消息队列通过Looper与线程关联上，而Handler又与Looper关联，因此，Handler最终就和线程，线程的消息队列关联成功。只有更新UI的Handler在主线程中创建，handleMessage在会在UI线程中执行。<br></p><p>创建Looper成功后，需要执行消息循环，而消息循环的建立通过Looper.loop()方法，源代码核心部分如下:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void loop() &#123;</span><br><span class="line">  final Looper me = myLooper();</span><br><span class="line">  if (me == null) &#123;</span><br><span class="line">      throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  final MessageQueue queue = me.mQueue;  // 1.获取消息队列</span><br><span class="line">  for (;;) &#123;  // 2.死循环</span><br><span class="line">   Message msg = queue.next();  // 3.依次获取消息</span><br><span class="line">     if (msg == null) &#123;</span><br><span class="line">       // No message indicates that the message queue is quitting.</span><br><span class="line">       return;</span><br><span class="line">    &#125;</span><br><span class="line">    //代码省略</span><br><span class="line">    msg.target.dispatchMessage(msg);  // 4.处理消息</span><br><span class="line">    //代码省略</span><br><span class="line">    msg.recycleUnchecked();  // 5.回收消息</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上述程序中可以得出，loop方法中实质就是建立一个死循环，通过消息队列一次取出消息，最后处理消息的过程。对Looper进行总结，通过Looper.perpare()创建Looper对象，且保存在sThreadLocal中，通过Looper.loop()来执行消息循环。这两步通常成对出现，缺一不可。<br></p><p>最后分析消息处理机制，从上述代码中第4步通过msg.target.dispatchMessage(msg)来处理消息。其中msg为Message类型，源代码如下:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final class Message implements Parcelable&#123;</span><br><span class="line">  Handler target;  // target处理</span><br><span class="line">  Runnable callback;  // Runnable类型的callback</span><br><span class="line">  Message next;  // 下一条消息，消息队列是链式存储</span><br><span class="line"></span><br><span class="line">  //代码省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从源代码中可以看出，target是Handler类型。实际上仍旧是通过Handler将消息投递给消息队列，消息队列又将消息分发给Handler来处理。接下来继续从源代码进行分析：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//消息处理函数，子类覆写</span><br><span class="line">public void handleMessage(Message msg)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private final void handleCallback(Message msg)&#123;</span><br><span class="line">  msg.callback.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//消息分发</span><br><span class="line">private void dispatchMessage(Message msg)&#123;</span><br><span class="line">  if (msg.callback != null)&#123;</span><br><span class="line">    handleCallback(msg);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    if (mCallback != null)&#123;</span><br><span class="line">      if (mCallback.handleMessage(msg))&#123;</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handleMessage(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上述程序中可以看到，dispatchMessage只是一个分发的方法，如果Runnable类型的callback为空，则执行handleMessage处理消息，该方法为空，则将更新UI的代码写在该函数中；如果callback不为空，则执行handleCallback来处理，该方法调用callback的run方法。则其实是Handler分发的两种类型，比如我们post(Runnable callback)则 callback不为空，我们使用Handler使用sendMessage时通常不会社会资callback，因此，就执行handleMessage这个分支。实现如下：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public final boolean post(Runnable r)&#123;</span><br><span class="line">  return  sendMessageDelayed(getPostMessage(r), 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static Message getPostMessage(Runnable r) &#123;</span><br><span class="line">  Message m = Message.obtain();</span><br><span class="line">  m.callback = r;</span><br><span class="line">  return m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final boolean sendMessageDelayed(Message msg, long delayMillis)&#123;</span><br><span class="line">  if (delayMillis &lt; 0) &#123;</span><br><span class="line">    delayMillis = 0;</span><br><span class="line">  &#125;</span><br><span class="line">  return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123;</span><br><span class="line">  MessageQueue queue = mQueue;</span><br><span class="line">  if (queue == null) &#123;</span><br><span class="line">     RuntimeException e = new RuntimeException(</span><br><span class="line">          this + &quot; sendMessageAtTime() called with no mQueue&quot;);</span><br><span class="line">            Log.w(&quot;Looper&quot;, e.getMessage(), e);</span><br><span class="line">            return false;</span><br><span class="line">  &#125;</span><br><span class="line">  return enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上述代码可以看出，在post(Runnable r)时，会将Runnable包装成Message对象，并且将Runnable对象设置给Message对象的callback字段，最后将该Message对象插入消息队列。<br></p><p>无论是post一个Runnable还是Message，都会调用sendMessageDelayed(msg,time)方法。Handler最终将消息追加到MessageQueue中，而Looper不断的从MessageQueue中读取消息，并调用Handler的dispatchMessage消息，此时消息会源源不断的产生，添加到MessageQueue中。Android应用就成功运转了<br></p><blockquote><p><strong>Notes:</strong>创建Handler之前先执行Looper.perpare(),然后添加Looper.loop().否则将会出现错误.<br>正确演示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new Thread()&#123;</span><br><span class="line">  Handler handler =null;</span><br><span class="line">  public void run()&#123;</span><br><span class="line">    Looper.prepare();</span><br><span class="line">    handler=new Handler();</span><br><span class="line">    Looper.loop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android四大组件之Activity详解</title>
      <link href="/2018/08/01/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8BActivity%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/08/01/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8BActivity%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h4 id="Activity生命周期："><a href="#Activity生命周期：" class="headerlink" title="Activity生命周期："></a>Activity生命周期：</h4><p><img src="http://img.blog.csdn.net/20170711120007533?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZW5vdWdoX2VtcHR5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>onCreate：在Acitivty第一次创建时调用，用于做初始化的工作<br>onStart：onCreate调用后调用，此次界面对用户来说无法看见<br>onResume：此次界面可见并显示到前台，且当前Acitvity位于当前栈顶，并且处于运行状态<br>onPause：表示当前Activity正在停止，常做一些存储数据、停止动画等工作(不做耗时操作)<br>onStop：表示当前Activity即将停止，一般做微量级的回收工作<br>onDestory：表示当前Activity即将被销毁，可做一些回收工作和最终的资源释放<br>onRestart：表示当前Activity正在重新启动，当前Activity从不可见状态变化为可见状态  </p><h4 id="Activity的构成"><a href="#Activity的构成" class="headerlink" title="Activity的构成"></a>Activity的构成</h4><p><img src="http://img.blog.csdn.net/20170711115955775?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZW5vdWdoX2VtcHR5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>PhoneWindow是Window的实现类，而Window之下包含一个DecorView，DecorView实际是页面的顶级视图，开发是设置的布局资源添加到系统布局的mContentParent中，android解析XML方法（SAX、Pull、Dom三种方式）</p><h4 id="Activity的四种启动模式-standard-singleTop-singleTask-singleInstance"><a href="#Activity的四种启动模式-standard-singleTop-singleTask-singleInstance" class="headerlink" title="Activity的四种启动模式(standard,singleTop,singleTask,singleInstance)"></a>Activity的四种启动模式(standard,singleTop,singleTask,singleInstance)</h4><p>1：standard(标准启动模式)栈内允许有多个实例，互不影响<br>2：singleTop 当以singleTop为启动模式的Activity再次启动时，如果当前已经有一个实例位于栈顶，当再次调用原来的onNewIntent()函数，栈顶不会新加入一个实例。如果实例不在栈顶，则与standard标准启动一样<br>3：singleTask 如果一个Activity设置了该启动模式，任务栈中只能存在一个该Activity的实例。如果任务栈中存在一个Activity实例，则销毁当前Activity栈内位于实例之前的所有Activity实例，最终让该Activity实例位于栈顶。同时调用该Activity的onNewIntent()函数<br>4：singleInstance 设置singleInstance模式的Activity会在一个单独的任务栈中开启实例，当再次启动该Activity实例时，会重用已存在的任务与实例，并调用该实例的onNewIntent()函数，将intent实例中传递到该实例中</p><p><strong>Note:</strong>（仍旧将任务栈中X前的实例全部取消）</p><p>  对于singleTask作为启动模式的实例X，有选择其所需要的任务栈，例如本身主任务栈为S1,且当前任务栈中不存在X实例，若所需要的任务栈为S2，且任务栈S2不存在，则创建S2与X实例，并将实例X存入栈S2中<br>  另一种情况下，假设X所需的任务栈为S1，其他情况如上述例子所示，由于S1任务栈已经存在，所以系统会直接创建X的实例并将其导入栈S1中</p><p><strong>设置启动模式方法：</strong></p><p>第一种：</p><pre><code>&lt;activity    android:name=&quot;com.sample.sampleActivity&quot;    android:launchMode=&quot;singleTask&quot;    android:label=&quot;@string/app_name&quot;/&gt;</code></pre><p>第二种：</p><blockquote></blockquote><p>Intent intent=new Intent();<br>intent.setClass(MainActivity.this,sampleActivity.class);<br>intent.addFalgs(Intent.FLAG_ACTIVITY_NEW_TASK);<br>startActivity(intent);</p><p><strong>Notes:</strong> 第一种无法直接为Activity设定FALG_ACTIVITY_CLEAR_TOP表示，而第二种方式无法为Activity指定singleInstance模式</p><h4 id="Activity的Flags"><a href="#Activity的Flags" class="headerlink" title="Activity的Flags"></a>Activity的Flags</h4><ul><li>FALG_ACTIVITY_NEW_TASK（对应Activity的singletask启动模式）</li><li>FALG_ACTIVITY_SINGLE_TOP （对应Activity的singletop启动模式）</li><li>FALG_ACTIVITY_CLEAR_TOP（具有次标记的Activity，当他启动时，在同一任务栈中所有位于它上面的Activity都要出栈，一般与singleTask启动模式一起出现，如果启动的实例已经存在，系统就会调用onNewIntent）</li><li>FALG_ACTIVITY_EXCLUDE_FROM_RESCENTS（具有这个标记的Activity不会出现在历史的Activity的列表中，等同与android:excludeFromRecents=”true”）</li></ul><h4 id="异常情况下的生命周期分析"><a href="#异常情况下的生命周期分析" class="headerlink" title="异常情况下的生命周期分析"></a>异常情况下的生命周期分析</h4><p><img src="http://img.blog.csdn.net/20170711115934148?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZW5vdWdoX2VtcHR5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>1、情况1：资源相关的系统配置发生改变导致Activity被杀死并重新创建<br>横竖屏突然转换，在默认情况下，Activity就会被销毁并且重新创建，系统先调用onSaveInstanceSate来保存当前Activity的状态。该方法调用在onStop之前，与onPause没有时序关系。当Activity在被重新创建之后，系统会调用onRestoreInstanceSate和onCreate方法来判断Activity是否被创建了，如果被重建了，那么我们就可以取出之前保存的数据并恢复，从时序上来说，onRestoreInstanceSate的调用在onStart上。类似TextView源码中包含onSaveInstanceSate方法保存控件内容。在AndroidManifest文件中设置android:configChanges=”orientation”保证屏幕方向固定，此时即使手机旋转界面仍旧保持原来方向不发生改变<br></p><p>2、情况2：Activity按照优先级从高到低，可以分为如下三种<br>(1) 前台Activity—正在和用户交互的Activity，优先级最高<br>(2) 可见但非前台Activity—比如Activity中弹出一个对话框，则背后的Activity就是属于这种情况，可见但位于后台无法与用户直接交互<br>(3) 后台Activity—已经被暂停的Activity，比如执行了onStop，优先级最低。</p>]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git添加SSH Key</title>
      <link href="/2018/08/01/Git%E6%B7%BB%E5%8A%A0SSH-Key/"/>
      <url>/2018/08/01/Git%E6%B7%BB%E5%8A%A0SSH-Key/</url>
      <content type="html"><![CDATA[<p>1：设置姓名和邮箱地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;username&quot;</span><br><span class="line">git config --global user.email &quot;youremail@email.com&quot;</span><br></pre></td></tr></table></figure></p><p>2:设置SSH Key<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail@email.com&quot;</span><br></pre></td></tr></table></figure></p><p>输入密码后进入C:\Users\boy.ssh查看id_rsa.pub内的内容并且复制</p><p>or</p><p>输入 cat ~/.ssh/id_rsa.pub直接查看内容复制</p><p>3：进入github设置控制板添加ssh key，输入以下指令测试是否成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></p><p>如果出现”Hi username! You’ve successfully …”即为成功</p>]]></content>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android基础之Intent篇</title>
      <link href="/2018/08/01/Android%E5%9F%BA%E7%A1%80%E4%B9%8BIntent%E7%AF%87/"/>
      <url>/2018/08/01/Android%E5%9F%BA%E7%A1%80%E4%B9%8BIntent%E7%AF%87/</url>
      <content type="html"><![CDATA[<h3 id="无返回值："><a href="#无返回值：" class="headerlink" title="无返回值："></a>无返回值：</h3><p><strong>MainActivity.class</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent(MainActivity.this,TargetAcitvity.class);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure></p><p>or</p><p><strong>AndroidManifest.xml</strong><br>设置&lt;intent-filter&gt;</p><pre>&lt;activity            android:name=".TargetAcitvity" >            &lt;intent-filter>                &lt;action android:name="personal_label" />                &lt;category android:name="android.intent.category.DEFAULT" />            &lt;/intent-filter>&lt;/activity></pre><p><strong>MainActivity.class</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent();</span><br><span class="line">intent.setAction(&quot;personal_label&quot;);</span><br><span class="line">intent.addCategory(&quot;android.intent.category.DEFAUL&quot;);</span><br></pre></td></tr></table></figure></p><h3 id="携带传输数据："><a href="#携带传输数据：" class="headerlink" title="携带传输数据："></a>携带传输数据：</h3><p><strong>MainActivity</strong><br>在新建Intent对象时对Intent对象调用putExtra(key,content)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent=new Intent(this,TargetAcitvity.class);</span><br><span class="line">intent.putExtra(&quot;test&quot;,&quot;test&quot;);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure></p><p><strong>TargetAcitvity</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_me);</span><br><span class="line">    //获取数据</span><br><span class="line">    Intent intent = getIntent();</span><br><span class="line">    String account=intent.getStringExtra(&quot;account&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>返回值类型</strong></p><p><strong>MainActivity</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent(RegisterActivity.this,TargetAcitvity.class);</span><br><span class="line">startActivityForResult(intent, 1);</span><br><span class="line"></span><br><span class="line">@Override  </span><br><span class="line">protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;  </span><br><span class="line">    super.onActivityResult(requestCode, resultCode, data);   </span><br><span class="line">    if(resultCode==2)&#123;  </span><br><span class="line">        if(requestCode==1)&#123;</span><br><span class="line">            Log.i(&quot;test&quot;,&quot;test&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>TargetAcitvity</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent();</span><br><span class="line">setResult(2, intent);</span><br><span class="line">finish();</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Andorid使用ksoap2进行WebService通信</title>
      <link href="/2018/08/01/Andorid%E4%BD%BF%E7%94%A8ksoap2%E8%BF%9B%E8%A1%8CWebService%E9%80%9A%E4%BF%A1/"/>
      <url>/2018/08/01/Andorid%E4%BD%BF%E7%94%A8ksoap2%E8%BF%9B%E8%A1%8CWebService%E9%80%9A%E4%BF%A1/</url>
      <content type="html"><![CDATA[<p>WebService 是一种基于SOAP协议的远程调用标准。通过WebService可以将不同操作系统平台，不同语言、不同技术整合到一起。在Android SDK中并没有提供调用WebService的库，因此，需要使用第三方类库（KSOAP2）来调用WebService。</p><p>示例代码分为两部分，android端与Web端（Android studio，VS2015）</p><ul><li><strong>Web端</strong></li></ul><p>使用VS创建一个新项目，选择Visual C# –&gt; web –&gt;ASP.NET Web应用程序，在资源管理器中打开后缀为.asmx文件进行修改</p><p><strong>代码部分：</strong></p><pre><code>namespace WebService1{    /// &lt;summary&gt;    /// WebService1 的摘要说明    /// &lt;/summary&gt;    [WebService(Namespace = &quot;http://tempuri.org/&quot;)]    [WebServiceBinding(ConformsTo = WsiProfiles.BasicProfile1_1)]    [System.ComponentModel.ToolboxItem(false)]    // 若要允许使用 ASP.NET AJAX 从脚本中调用此 Web 服务，请取消注释以下行。     // [System.Web.Script.Services.ScriptService]    public class WebService1 : System.Web.Services.WebService    {        [WebMethod]        public string HelloWorld()        {            return &quot;Hello&quot;;        }        [WebMethod]        public string[] EchoMessage(string msg1,string msg2)        {            string []name = { msg1, msg2 };            return name;        }    }}</code></pre><ul><li><strong>android端（在AndroidManifest文件中添加网络连接权限）</strong></li></ul><p>Android端demo分为三个文件:<strong>MainActivity.java</strong>,<strong>Nettask.java</strong>,<strong>Netsetting.java</strong></p><pre>MainActivity.java:加载布局文件提高测试效果Nettask.java：Ksoap2包的使用，进行网络通信Netsetting.java：网络通信基本设置信息</pre><p><strong>MainActivity.java主要代码展示:</strong></p><pre><code>private void initBtn() {      //初始化按钮点击事件      View btnHelloWorld = this.findViewById(R.id.btnHelloWorld);      btnHelloWorld.setOnClickListener(new OnClickListener() {          @Override          public void onClick(View v) {              Map&lt;String, String&gt; values = new HashMap&lt;String, String&gt;();              //设置参数              values.put(&quot;msg&quot;, &quot;It&apos;s android data&quot;);              //发出请求              Request(mNetSetting.getMethod_Hello());          }      });      View btnEchoMessage = this.findViewById(R.id.btnEchoMessage);      btnEchoMessage.setOnClickListener(new OnClickListener() {          @Override          public void onClick(View v) {              Map&lt;String, String&gt; values = new HashMap&lt;String, String&gt;();              //设置参数              values.put(&quot;msg1&quot;, &quot;It&apos;s android data one&quot;);              values.put(&quot;msg2&quot;, &quot;It&apos;s android data two&quot;);              //发出请求              Request(mNetSetting.getMethod_Echo(), values);          }      });  }  /*  * Push Request for WebService  * 使用AsyncTask完成网络通信（直接放入主线程会直接报错）  */  public void Request(Object... params) {      new AsyncTask&lt;Object, Object, String&gt;() {          //Change the Textview content          String txt=new String();          @Override          protected String doInBackground(Object... params) {              if (params != null &amp;&amp; params.length == 2) {                  txt= mNetTask.Distribute_WebService((String) params[0],                          (Map&lt;String, String&gt;) params[1]);              } else if (params != null &amp;&amp; params.length == 1) {                  txt= mNetTask.Distribute_WebService((String) params[0], null);              } else {                  return null;              }              return null;          }          protected void onPostExecute(String result) {              //在主页面的Textview显示返回信息              tvMessage.setText(&quot;Information from Server : &quot; + txt);          };      }.execute(params);  }</code></pre><p><strong>Nettask.java代码展示:</strong></p><pre><code>public class NetTask {    private NetSetting mNetSetting=new NetSetting();    //initialize the Method in Package &quot;ksoap2&quot; and get the object form SoapSerializationEnvelope    //初始化方法ksoap包中的方法（如果是单纯使用不需要明白下面的意思,类似一个模板的使用）    public SoapSerializationEnvelope DoGet(String MethodName, Map&lt;String, String&gt; Params){        // 1、Define the WebService Space name and Method        SoapObject request = new SoapObject(mNetSetting.getNamespace()  , MethodName);        //Set the Method&apos;s parameter if not exists then ignore it        //获取从MainActivity内的request方法中的参数，以及参数类型        if (Params != null) {            Iterator iter = Params.entrySet().iterator();            while (iter.hasNext()) {                Map.Entry entry = (Map.Entry) iter.next();                request.addProperty((String) entry.getKey(),                        (String) entry.getValue());            }        }        /*         *   3、Create and use Webservice method to generate soap request         *      parameter is the vserion name of Soap protocol and you can check it&apos;s Instructions to know it(eg:WebService1.asmx?WSDL)         *   3、创建并且使用Webservice方法产生请求         *      new SoapSerializationEnvelope(SoapEnvelope.VER12)方法中的VER12为soap协议的版本号         */        SoapSerializationEnvelope envelope = new SoapSerializationEnvelope(                SoapEnvelope.VER12);        envelope.bodyOut = request;        // when you use donet protocol then use true        envelope.dotNet = true;        //envelope为WEBSERVICE传输内容        HttpTransportSE http = new HttpTransportSE(mNetSetting.getURL());        // use call() to connect Server        // call()方法实际为连接服务器        try {            http.call(null, envelope);        } catch (HttpResponseException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        } catch (XmlPullParserException e) {            e.printStackTrace();        }        return envelope;    }    //Change Method according to the MethodName    //根据请求选择不同的方法    public String Distribute_WebService(String MethodName, Map&lt;String, String&gt; Params){        if(MethodName.equals(mNetSetting.getMethod_Hello()))            return Hello_CallWebService(MethodName,Params);        else{            return Echo_CallWebService(MethodName,Params);        }    }    //Hello_CallWebService    public String Hello_CallWebService(String MethodName, Map&lt;String, String&gt; Params) {        SoapSerializationEnvelope envelope=DoGet(MethodName,Params);        try {            //单个数据选择SoapPrimitive            final SoapPrimitive result = (SoapPrimitive) envelope.getResponse();            if (result!= null) {                Log.d(&quot;----ReceivedMessage----&quot;, result.toString());                return result.toString();            }        } catch (SoapFault e) {            Log.e(&quot;----WrongMessage---&quot;, e.getMessage());            e.printStackTrace();        }        return null;    }    //Echo_CallWebService    public String Echo_CallWebService(String MethodName, Map&lt;String, String&gt; Params) {        SoapSerializationEnvelope envelope=DoGet(MethodName,Params);        try{            //复杂数据选择SoapObject            final SoapObject result = (SoapObject) envelope.getResponse();            if (result!= null) {                //通过使用getProperty()方法可以实现调用传输过来的方法                Log.d(&quot;----ReceivedMessage----&quot;, result.getProperty(0).toString());                Log.d(&quot;----ReceivedMessage----&quot;, result.getProperty(1).toString());                return result.toString();            }        } catch (SoapFault e) {            Log.e(&quot;----WrongMessage---&quot;, e.getMessage());            e.printStackTrace();        }        return null;    }}</code></pre><p><strong>Netsetting.java:</strong></p><pre><code>public class NetSetting {    public NetSetting(){};    //Method Name 值与Web端相应方法的值必须保持一致    final String METHOD_HELLO_WORLD = &quot;HelloWorld&quot;;    final String METHOD_ECHO_MESSAGE = &quot;EchoMessage&quot;;    //Server Url    final String WEB_SERVICE_URL = &quot;http://ip/WebService1.asmx&quot;;    //WebService Space Name    final String Namespace = &quot;http://tempuri.org/&quot;;    //Get Space Name    public String getNamespace(){        return Namespace;    }    //Get WebService Url    public String getURL(){        return WEB_SERVICE_URL;    }    //Get Mthod Name &quot;HelloWorld&quot;    public String getMethod_Hello(){        return METHOD_HELLO_WORLD;    }    //Get Mthod Name &quot;EchoMessage&quot;    public String getMethod_Echo(){        return METHOD_ECHO_MESSAGE;    }}</code></pre><p>这里为全代码的demo地址<br><a href="http://download.csdn.net/detail/enough_empty/9628832" target="_blank" rel="noopener">http://download.csdn.net/detail/enough_empty/9628832</a><br>git 地址<br><a href="https://github.com/yclog/ksoap2-webservice-demo" target="_blank" rel="noopener">https://github.com/yclog/ksoap2-webservice-demo</a></p><p>参考博客<br>还是你最好:<a href="http://www.cnblogs.com/gzggyy/archive/2011/06/21/2086140.html" target="_blank" rel="noopener">http://www.cnblogs.com/gzggyy/archive/2011/06/21/2086140.html</a></p><p><strong>Ps:博主使用了各种手段设置WEB_SERVICE_URL中的IP都以android端连接失败告终，最后因为时间关系强行将web服务发布到服务器上，才解决了这个问题<br>之前尝试改为<a href="http://10.0.2.2/WebService1.asmx" target="_blank" rel="noopener">http://10.0.2.2/WebService1.asmx</a> 仍旧存在问题，如果有博友在本地成功希望能留下评论交流，谢谢</strong> </p>]]></content>
      
      
        <tags>
            
            <tag> Android, WebService </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>centos+wordpress搭建博客</title>
      <link href="/2018/07/31/centos-wordpress%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2018/07/31/centos-wordpress%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p>此教程使用wordpress（世界上最大的博客系统）搭建网站。相信即便是小白也能搭建出自己喜欢的网站。</p><p>要搭建自己的博客网站，首先要进行购买vps，如果打算用服务器顺带搭建VPN的话可以使用国外服务器进行搭建博客，国内最好的云服务提供商是阿里云，费用略贵一些，但安全性以及性能来说都是其他几家不能达到的。免费主机比较出名的有主机公园，注册即可以使用一年免费的云服务器。国外vps性能最好的是linode，不过需要visa卡进行注册购买，另一个性价比相当高的vps供应商是digital ocean，本供应商具有较多优惠，获取优惠链接<a href="http://blog.csdn.net/enough_empty/article/details/51334963" target="_blank" rel="noopener">digital ocean</a></p><p>国内购买域名主要有新网与万网两个大型域名购买网站， 但购买域名需要备案，故推荐<a href="https://sg.godaddy.com/zh/，全球最大域名网站，现在也支持支付宝付账了，一个.com域名价格大概在50RMB左右，不过需要使用godaddy的优惠券，这些都是很容易在网上找到的。" target="_blank" rel="noopener">https://sg.godaddy.com/zh/，全球最大域名网站，现在也支持支付宝付账了，一个.com域名价格大概在50RMB左右，不过需要使用godaddy的优惠券，这些都是很容易在网上找到的。</a></p><p>godaddy提供的域名服务器没有放置在国内，有可能会被查封dns无法解析域名，推荐使用dnspod进行域名解析。<br><img src="http://img.blog.csdn.net/20160418161400646" alt="这里写图片描述"></p><p>解析域名之后，添加自有服务器的IP，选择@主机记录</p><p><img src="http://img.blog.csdn.net/20160418161827685" alt="这里写图片描述"></p><p>设置好IP之后进入godaddy的dns管理页面更改原有域名服务器即可</p><p><img src="http://img.blog.csdn.net/20160418162001359" alt="这里写图片描述"></p><p><strong>接下来对vps进行操作</strong></p><p><strong>1.使用yum安装 mysql、apache、php</strong></p><p>登陆你的linux系统，在shell窗口输入以下命令：</p><p>yum -y install mysql-server httpd php php-mysql unzip wget</p><p>添加mysql、apache服务</p><p>chkconfig httpd on<br>chkconfig mysqld on</p><p>启动服务</p><p>service mysqld start<br>service httpd start</p><p><strong>2. 为wordpress创建数据库、用户名</strong></p><p>设置mysql root 密码 执行/usr/bin/mysql_secure_installation，按提示完成操作，设置root密码等</p><p>登录mysql：mysql -uroot -p</p><p>创建WordPress数据库：CREATE DATABASE wordpress;</p><p>创建WordPress用户： GRANT ALL PRIVILEGES ON <em>.</em> TO ‘用户名‘@localhost IDENTIFIED BY ‘用户密码’ WITH GRANT OPTION;   </p><p>FLUSH   PRIVILEGES; </p><p>刷新：FLUSH PRIVILEGES;</p><p>退出mysql：\q</p><p><strong>3. 下载wordpress跟安装</strong></p><p>cd /var/www/html</p><p>wget <a href="https://cn.wordpress.org/wordpress-4.5-zh_CN.zip（以后的版本可以去wordpress网站去找安装的下载连接即可）" target="_blank" rel="noopener">https://cn.wordpress.org/wordpress-4.5-zh_CN.zip（以后的版本可以去wordpress网站去找安装的下载连接即可）</a><br><img src="http://img.blog.csdn.net/20160418163023591" alt="这里写图片描述"></p><p>unzip wordpress-3.6.1zh_CN.zip<br>设置WordPress根目录owner<br>chown -R apache:apache wordpress<br><strong>将cd /var/www/html/wordpress内的所有文件移动到cd /var/www/html文件夹下</strong></p><p><strong>4. 配置wordpress</strong><br>cd /var/www/html  cp wp-config-sample.php    wp-config.php    </p><p>vi wp-config.php加入一行：<br>define(‘FS_METHOD’, ‘direct’); （WP后台直接操作文件，不通过FTP）</p><p>define(‘DB_NAME’, ‘database_name_here’);（database_name_here 换成 wordpress）<br>define(‘DB_USER’, ‘username_here’);（username_here 换成 wordpress）<br>define(‘DB_PASSWORD’, ‘password_here’);（password_here 换成 上面设置的 wordpress_password）</p><p>进入WordPress后台管理</p><p><a href="http://your-server-ip-or-hostname/wp-admin/install.php，进入这个页面进行安装，安装完毕后就能进去后台对博客系统进行管理了，如安装主题、插件等" target="_blank" rel="noopener">http://your-server-ip-or-hostname/wp-admin/install.php，进入这个页面进行安装，安装完毕后就能进去后台对博客系统进行管理了，如安装主题、插件等</a></p><p><a href="http://your-server-ip" target="_blank" rel="noopener">http://your-server-ip</a> 如果能进入这个页面表面你的wordpress博客系统已经成功搭建了</p><p>参考博客：<br>软件开发程序员博客文章收藏网：<a href="http://www.programgo.com/article/1874486129/" target="_blank" rel="noopener">http://www.programgo.com/article/1874486129/</a><br>季枫：<a href="http://www.cnblogs.com/jifeng/archive/2011/03/06/1972183.html" target="_blank" rel="noopener">http://www.cnblogs.com/jifeng/archive/2011/03/06/1972183.html</a></p><p>欢迎各位朋友对以上内容提出问题</p>]]></content>
      
      
        <tags>
            
            <tag> WordPress </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
